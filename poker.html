import tkinter as tk
from tkinter import Canvas, Frame, Label, Button, Entry, messagebox
import random
import requests
from io import BytesIO
from PIL import Image, ImageTk
from treys import Card, Evaluator, Deck
import os
import time

# Global cache for card images.
image_cache = {}

def get_card_image(card, width=120, height=180, face_up=True):
    """Fetch (or return cached) image for a card from the Deck of Cards API."""
    if not face_up:
        card_back = Image.new("RGB", (width, height), color="darkblue")
        return ImageTk.PhotoImage(card_back)
    card_str = Card.int_to_str(card)  # e.g., "Ah"
    rank = card_str[0].upper()
    suit = card_str[1].upper()
    if rank == "T":
        rank = "0"
    key = f"{rank}{suit}"
    if key in image_cache:
        return image_cache[key]
    url = f"https://deckofcardsapi.com/static/img/{key}.png"
    try:
        response = requests.get(url)
        response.raise_for_status()
        img = Image.open(BytesIO(response.content))
    except Exception as e:
        print(f"Error loading {url}: {e}")
        return None
    img = img.resize((width, height), Image.Resampling.LANCZOS)
    photo = ImageTk.PhotoImage(img)
    image_cache[key] = photo
    return photo

# ---------------------------
# Poker game logic (with blinds and button)
# ---------------------------
class PokerGame:
    def __init__(self):
        self.num_players = 4
        self.big_blind_amt = 50
        self.small_blind_amt = 25
        self.button_position = 1  # start with player 1 as dealer/button
        self.reset_game()

    def next_active_player(self, pid):
        return (pid % self.num_players) + 1

    def reset_game(self):
        """Reset deck, assign button/blinds, post blinds, and deal hole cards."""
        self.deck = Deck()
        self.evaluator = Evaluator()
        self.players = {
            pid: {"hand": [], "balance": 1000, "active": True, "bet": 0}
            for pid in range(1, self.num_players + 1)
        }
        self.pot = 0
        self.community = []
        self.stage = "pre-flop"
        self.current_bet = 0

        # Rotate button clockwise.
        self.button_position = self.next_active_player(self.button_position)
        # Determine blinds.
        self.small_blind = self.next_active_player(self.button_position)
        self.big_blind = self.next_active_player(self.small_blind)

        # Post blinds.
        self.players[self.small_blind]["balance"] -= self.small_blind_amt
        self.players[self.small_blind]["bet"] = self.small_blind_amt
        self.players[self.big_blind]["balance"] -= self.big_blind_amt
        self.players[self.big_blind]["bet"] = self.big_blind_amt
        self.pot = self.small_blind_amt + self.big_blind_amt
        self.current_bet = self.big_blind_amt

        # Deal hole cards.
        for pid in self.players:
            self.players[pid]["hand"] = self.deck.draw(2)
            self.players[pid]["active"] = True

        # Pre-flop action starts with the player to the left of the big blind.
        self.current_player = self.next_active_player(self.big_blind)

    def start_new_betting_round(self):
        """Reset bets for a new betting round and set the current player."""
        for pid in self.players:
            if self.players[pid]["active"]:
                self.players[pid]["bet"] = 0
        self.current_bet = 0
        if self.stage == "pre-flop":
            self.current_player = self.next_active_player(self.big_blind)
        else:
            self.current_player = self.next_active_player(self.button_position)

    def deal_community(self, count):
        new_cards = self.deck.draw(count)
        self.community.extend(new_cards)
        if len(self.community) == 3:
            self.stage = "flop"
        elif len(self.community) == 4:
            self.stage = "turn"
        elif len(self.community) == 5:
            self.stage = "river"

    def evaluate_hands(self):
        best_score = None
        winner = None
        for pid, data in self.players.items():
            if not data["active"]:
                continue
            score = self.evaluator.evaluate(data["hand"], self.community)
            if best_score is None or score < best_score:
                best_score = score
                winner = pid
        return winner

    def process_bet(self, action, player_id, raise_amount=0):
        if action == "fold":
            self.players[player_id]["active"] = False
        elif action == "raise":
            bet = raise_amount
            if self.players[player_id]["balance"] >= bet:
                self.players[player_id]["balance"] -= bet
                self.players[player_id]["bet"] += bet
                self.pot += bet
                self.current_bet = max(self.current_bet, self.players[player_id]["bet"])
        elif action == "call":
            bet_needed = self.current_bet - self.players[player_id]["bet"]
            if bet_needed > 0:
                if self.players[player_id]["balance"] >= bet_needed:
                    self.players[player_id]["balance"] -= bet_needed
                    self.players[player_id]["bet"] += bet_needed
                    self.pot += bet_needed
        elif action == "check":
            if self.players[player_id]["bet"] < self.current_bet:
                return False  # invalid check
        return True

    def is_betting_round_over(self):
        active_players = [pid for pid, data in self.players.items() if data["active"]]
        if len(active_players) <= 1:
            return True
        for pid in active_players:
            if self.players[pid]["bet"] < self.current_bet:
                return False
        return True

    def showdown(self):
        winner = self.evaluate_hands()
        if winner:
            self.players[winner]["balance"] += self.pot
        self.stage = "showdown"
        return winner

# ---------------------------
# Poker GUI (with revised stage advancement)
# ---------------------------
class PokerGUI:
    def __init__(self, root):
        print("Initializing PokerGUI...")
        self.root = root
        self.root.title("Texas Hold'em Poker")
        self.game = PokerGame()

        # Larger fonts for readability.
        self.default_font = ("Arial", 20, "bold")
        self.btn_font = ("Arial", 18, "bold")
        self.info_font = ("Arial", 18, "bold")
        self.card_width = 90
        self.card_height = 135

        self.setup_layout()
        self.preload_ui_images()
        self.update_table_ui()
        self.update_player_ui()
        self.update_community_ui()
        print("PokerGUI initialized.")

    def setup_layout(self):
        self.canvas = Canvas(self.root, bg="#1e1e1e")
        self.canvas.pack(fill="both", expand=True)
        self.screen_width = self.root.winfo_screenwidth()
        self.screen_height = self.root.winfo_screenheight()

        if os.path.exists("table.png"):
            try:
                table_img = Image.open("table.png")
                table_img = table_img.resize((self.screen_width, self.screen_height), Image.Resampling.LANCZOS)
                self.table_bg = ImageTk.PhotoImage(table_img)
                self.canvas.create_image(0, 0, anchor="nw", image=self.table_bg)
            except Exception as e:
                print("Error loading table.png:", e)
                self.draw_fallback_table()
        else:
            self.draw_fallback_table()

        self.player_positions = {
            1: (self.screen_width * 0.5, self.screen_height * 0.8),
            2: (self.screen_width * 0.15, self.screen_height * 0.4),
            3: (self.screen_width * 0.5, self.screen_height * 0.1),
            4: (self.screen_width * 0.85, self.screen_height * 0.4)
        }
        self.player_card_offsets = {
            1: [(-60, 0), (60, 0)],
            2: [(0, -60), (0, 60)],
            3: [(-60, 0), (60, 0)],
            4: [(0, -60), (0, 60)]
        }
        self.community_positions = []
        start_x = self.screen_width * 0.3
        step_x = self.screen_width * 0.08
        y = self.screen_height * 0.45
        for i in range(5):
            self.community_positions.append((start_x + i * step_x, y))

        self.player_card_items = {}
        for pid, pos in self.player_positions.items():
            x, y = pos
            offsets = self.player_card_offsets[pid]
            self.player_card_items[pid] = []
            for dx, dy in offsets:
                item = self.canvas.create_image(x + dx, y + dy, image=None)
                self.player_card_items[pid].append(item)

        self.community_items = []
        for pos in self.community_positions:
            item = self.canvas.create_image(pos[0], pos[1], image=None)
            self.community_items.append(item)

        self.pot_text = self.canvas.create_text(
            self.screen_width * 0.5,
            self.screen_height * 0.5,
            text="POT: 0",
            fill="white",
            font=("Arial", 26, "bold")
        )

        self.cash_items = {}
        for pid, pos in self.player_positions.items():
            x, y = pos
            rect = self.canvas.create_rectangle(x - 50, y + 40, x + 50, y + 60, fill="gold")
            text = self.canvas.create_text(x, y + 50, text="", fill="black", font=("Arial", 18, "bold"))
            self.cash_items[pid] = (rect, text)

        self.control_frame = Frame(self.root, bg="#222222")
        self.control_frame.pack(side="bottom", fill="x")

        self.stage_label = Label(
            self.control_frame,
            text="Stage: Pre-Flop",
            font=self.info_font,
            bg="#222222",
            fg="white"
        )
        self.stage_label.pack(side="left", padx=15, pady=10)

        self.fold_button = Button(
            self.control_frame,
            text="Fold",
            font=self.btn_font,
            bg="#d9534f",
            fg="white",
            command=self.fold
        )
        self.fold_button.pack(side="left", padx=10, pady=10)

        self.call_button = Button(
            self.control_frame,
            text="Call/Check",
            font=self.btn_font,
            bg="#5cb85c",
            fg="white",
            command=self.call
        )
        self.call_button.pack(side="left", padx=10, pady=10)

        self.raise_button = Button(
            self.control_frame,
            text="Raise",
            font=self.btn_font,
            bg="#0275d8",
            fg="white",
            command=self.raise_bet
        )
        self.raise_button.pack(side="left", padx=10, pady=10)

        self.raise_entry = Entry(
            self.control_frame,
            font=self.info_font,
            width=5
        )
        self.raise_entry.insert(0, "100")
        self.raise_entry.pack(side="left", padx=10, pady=10)

        self.next_stage_button = Button(
            self.control_frame,
            text="Next Stage",
            font=self.btn_font,
            bg="#888888",
            fg="white",
            command=self.next_stage
        )
        self.next_stage_button.pack(side="left", padx=10, pady=10)

        self.showdown_button = Button(
            self.control_frame,
            text="Showdown",
            font=self.btn_font,
            bg="#ff9900",
            fg="white",
            command=self.showdown
        )
        self.showdown_button.pack(side="left", padx=10, pady=10)
        self.showdown_button.pack_forget()

    def draw_fallback_table(self):
        margin = 100
        self.canvas.create_oval(
            margin,
            margin,
            self.screen_width - margin,
            self.screen_height - margin,
            fill="seagreen",
            outline="black",
            width=5
        )

    def preload_ui_images(self):
        print("Preloading card images...")
        ranks = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "0", "J", "Q", "K"]
        suits = ["C", "D", "H", "S"]
        for suit in suits:
            for rank in ranks:
                key = f"{rank}{suit}"
                if key in image_cache:
                    continue
                url = f"https://deckofcardsapi.com/static/img/{key}.png"
                try:
                    response = requests.get(url)
                    response.raise_for_status()
                    img = Image.open(BytesIO(response.content))
                except Exception as e:
                    print(f"Error preloading {url}: {e}")
                    continue
                img = img.resize((self.card_width, self.card_height), Image.Resampling.LANCZOS)
                photo = ImageTk.PhotoImage(img)
                image_cache[key] = photo
        print("Preloading complete.")

    def update_table_ui(self):
        self.canvas.itemconfig(self.pot_text, text=f"POT: {self.game.pot}")
        for pid, pos in self.player_positions.items():
            balance = self.game.players[pid]["balance"]
            rect_id, text_id = self.cash_items[pid]
            height_scale = 100 / 1000
            x, y = pos
            rect_height = max(10, balance * height_scale)
            self.canvas.coords(rect_id, x - 50, y + 60 - rect_height, x + 50, y + 60)
            self.canvas.itemconfig(text_id, text=str(balance))
        self.stage_label.config(text=f"Stage: {self.game.stage.capitalize()}")

    def update_community_ui(self):
        for i, card in enumerate(self.game.community):
            photo = get_card_image(card, width=self.card_width, height=self.card_height)
            if photo:
                self.canvas.itemconfig(self.community_items[i], image=photo)
                self.canvas.image = photo
        for i in range(len(self.game.community), 5):
            self.canvas.itemconfig(self.community_items[i], image=None)

    def update_player_ui(self, reveal_all=False):
        for pid, items in self.player_card_items.items():
            hand = self.game.players[pid]["hand"]
            if pid == 1 or reveal_all:
                for i, card in enumerate(hand):
                    photo = get_card_image(card, width=self.card_width, height=self.card_height)
                    if photo:
                        self.canvas.itemconfig(items[i], image=photo)
            else:
                back_photo = get_card_image(None, width=self.card_width, height=self.card_height, face_up=False)
                for item in items:
                    self.canvas.itemconfig(item, image=back_photo)

    def fold(self):
        self.game.process_bet("fold", player_id=1)
        self.update_table_ui()
        self.post_user_action()

    def call(self):
        success = self.game.process_bet("call", player_id=1)
        if not success:
            self.game.process_bet("check", player_id=1)
        self.update_table_ui()
        self.post_user_action()

    def raise_bet(self):
        try:
            amt = int(self.raise_entry.get())
        except ValueError:
            amt = 100
        self.game.process_bet("raise", player_id=1, raise_amount=amt)
        self.update_table_ui()
        self.post_user_action()

    def post_user_action(self):
        # Execute CPU actions until it's the human's turn.
        self.run_cpu_actions()
        # Do not auto-advance the stage; let the user press "Next Stage."
        self.update_table_ui()
        self.update_player_ui()
        self.update_community_ui()

    def run_cpu_actions(self):
        pid = self.game.current_player
        while pid != 1:
            if not self.game.players[pid]["active"]:
                pid = self.game.next_active_player(pid)
                continue
            if self.game.is_betting_round_over():
                break
            self.cpu_action(pid)
            pid = self.game.next_active_player(pid)

    def cpu_action(self, pid):
        r = random.random()
        bet_needed = self.game.current_bet - self.game.players[pid]["bet"]
        hand_score = self.game.evaluator.evaluate(self.game.players[pid]["hand"], self.game.community)
        if bet_needed > 0:
            if hand_score < 3000 and r < 0.7:
                self.game.process_bet("call", pid)
            elif r < 0.1:
                self.game.process_bet("fold", pid)
            else:
                raise_amt = bet_needed + random.randint(50, 200)
                if raise_amt > self.game.players[pid]["balance"]:
                    self.game.process_bet("call", pid)
                else:
                    self.game.process_bet("raise", pid, raise_amount=raise_amt)
        else:
            if hand_score < 3000 and r < 0.2:
                raise_amt = random.randint(50, 150)
                if raise_amt > self.game.players[pid]["balance"]:
                    self.game.process_bet("check", pid)
                else:
                    self.game.process_bet("raise", pid, raise_amount=raise_amt)
            else:
                self.game.process_bet("check", pid)
        self.update_table_ui()
        self.update_player_ui()
        self.update_community_ui()
        self.root.update()
        time.sleep(0.5)

    def next_stage(self):
        # Start a new betting round.
        self.game.start_new_betting_round()
        if self.game.stage == "pre-flop":
            self.game.deal_community(3)
        elif self.game.stage == "flop":
            self.game.deal_community(1)
        elif self.game.stage == "turn":
            self.game.deal_community(1)
        elif self.game.stage == "river":
            self.update_table_ui()
            self.update_community_ui()
            self.update_player_ui()
            self.stage_label.config(text="Stage: River (Final Betting)")
            self.showdown_button.pack(side="left", padx=10, pady=10)
            return
        self.stage_label.config(text=f"Stage: {self.game.stage.capitalize()}")
        self.update_table_ui()
        self.update_community_ui()
        self.update_player_ui()
        # Removed auto-call to post_user_action so the user controls progression.

    def showdown(self):
        self.showdown_button.pack_forget()
        winner = self.game.showdown()
        self.update_player_ui(reveal_all=True)
        self.update_table_ui()
        self.update_community_ui()
        if winner:
            messagebox.showinfo("Showdown", f"Player {winner} wins the pot of {self.game.pot} credits!")
        else:
            messagebox.showinfo("Showdown", "No winner was determined.")
        self.reset_game()

    def reset_game(self):
        self.game.reset_game()
        self.showdown_button.pack_forget()
        self.stage_label.config(text="Stage: Pre-Flop")
        self.update_table_ui()
        self.update_community_ui()
        self.update_player_ui()

def main():
    print("Launching game...")
    root = tk.Tk()
    root.geometry("1280x720")
    app = PokerGUI(root)
    print("Game GUI created. Entering mainloop...")
    root.mainloop()
    print("Mainloop has ended.")

if __name__ == "__main__":
    main()
