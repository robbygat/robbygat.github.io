<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Texas Hold'em Poker</title>
    <!-- Google Fonts -->
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <!-- Font Awesome for icons -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <!-- particles.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <!-- GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- React Three Fiber -->
    <script src="https://unpkg.com/@react-three/fiber@8.0.27/dist/react-three-fiber.umd.js"></script>
    <!-- Material UI (MUI) -->
    <script src="https://unpkg.com/@mui/material@5.11.0/umd/material-ui.development.js"></script>
    <!-- PokerSolver for hand evaluation -->
    <script src="https://unpkg.com/pokersolver@2.2.0/dist/pokersolver.min.js"></script>
    <!-- React, ReactDOM and Babel -->
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      /* Global Reset and Variables */
      * { margin: 0; padding: 0; box-sizing: border-box; }
      :root {
        --primary-color: #ffffff;
        --accent-color: #ff4081;
        --bg-dark-green: #002200;  /* Website background */
        --bg-green: #006400;       /* Poker table background */
        --bg-gradient: linear-gradient(135deg, #008000, #006400);
        --font-family: 'Roboto', sans-serif;
      }
      body {
        font-family: var(--font-family);
        background-color: var(--bg-dark-green);
        overflow-x: hidden;
        position: relative;
      }
      /* Particles background */
      #particles-js {
        position: fixed;
        width: 100%;
        height: 100%;
        z-index: -3;
        background: var(--bg-dark-green);
      }
      /* Header */
      header {
        position: sticky;
        top: 0;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 20px;
        background: rgba(0, 0, 0, 0.8);
      }
      header h2 { color: var(--primary-color); font-size: 1.8rem; }
      header a {
        color: var(--primary-color);
        text-decoration: none;
        font-size: 1.2rem;
        transition: transform 0.3s;
      }
      header a:hover { transform: scale(1.2); color: var(--accent-color); }
      /* Timer and Stats */
      .timer, .stats {
        position: fixed;
        background: rgba(0,0,0,0.8);
        color: var(--primary-color);
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 1.2rem;
        z-index: 1000;
      }
      .timer { top: 70px; right: 20px; }
      .stats { top: 70px; left: 20px; }
      /* 3D Table rendered by React Three Fiber will be a canvas in a container */
      .table3D {
        position: relative;
        width: 100%;
        height: 100vh;
      }
      /* Overlay for 2D game UI */
      .game-ui {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none; /* UI overlays that don't block 3D scene */
      }
      /* Community Cards, Player Areas, Controls, Game Info */
      .community, .player, .controls, .game-info {
        pointer-events: auto;
      }
      .community {
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        z-index: 2;
      }
      .player {
        position: absolute;
        text-align: center;
        z-index: 2;
        padding: 5px;
        transition: box-shadow 0.3s;
        background: rgba(0,0,0,0.4);
        border-radius: 5px;
      }
      .player.active {
        box-shadow: 0 0 15px var(--accent-color);
      }
      .player.p1 { bottom: 10%; left: 45%; }
      .player.p2 { top: 35%; left: 5%; }
      .player.p3 { top: 5%; left: 45%; }
      .player.p4 { top: 35%; right: 5%; }
      .card {
        width: 90px;
        height: 135px;
        border: 2px solid #fff;
        border-radius: 8px;
        background: #fff;
        overflow: hidden;
        perspective: 1000px;
      }
      .card-inner {
        position: relative;
        width: 100%;
        height: 100%;
        transition: transform 0.8s ease;
        transform-style: preserve-3d;
      }
      .card-face {
        position: absolute;
        width: 100%;
        height: 100%;
        backface-visibility: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
      }
      .card-front { background: #fff; }
      .card-front.red { color: red; }
      .card-front.black { color: black; }
      .controls {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: #222;
        padding: 15px;
        display: flex;
        justify-content: center;
        gap: 10px;
        z-index: 1000;
      }
      .controls button {
        font-size: 1rem;
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background 0.3s, transform 0.3s;
      }
      .controls button:hover { transform: scale(1.05); }
      .btn-fold { background: #d9534f; color: #fff; }
      .btn-call { background: #5cb85c; color: #fff; }
      .btn-raise { background: #0275d8; color: #fff; }
      .btn-next { background: #888; color: #fff; }
      .btn-showdown { background: #ff9900; color: #fff; }
      .btn-new { background: #444; color: #fff; }
      .game-info {
        position: fixed;
        bottom: 70px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.8);
        color: var(--primary-color);
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 1.2rem;
        z-index: 1000;
      }
      @keyframes fadeInBounce {
        0% { opacity: 0; transform: scale(0.5); }
        50% { opacity: 0.7; transform: scale(1.2); }
        100% { opacity: 1; transform: scale(1); }
      }
      .animate-bounce { animation: fadeInBounce 0.8s ease-out; }
      @media (max-width: 768px) {
        .card { width: 70px; height: 105px; }
        .player { font-size: 0.9rem; }
        .controls button { font-size: 0.9rem; padding: 8px 15px; }
      }
    </style>
  </head>
  <body>
    <!-- Particles background -->
    <div id="particles-js"></div>
    <!-- Header with Home button -->
    <header>
      <a href="index.html" aria-label="Home"><i class="fas fa-home"></i> Home</a>
      <h2>Poker Arena</h2>
    </header>
    <!-- Timer and Stats -->
    <div class="timer" id="timer">30</div>
    <div class="stats" id="stats">Hands: 0</div>
    <!-- Main 3D Table Container -->
    <div class="table3D" id="table3D"></div>
    <!-- Overlay for 2D UI -->
    <div class="game-ui" id="root"></div>
    <!-- particles.js configuration (black particles) -->
    <script>
      particlesJS("particles-js", {
        "particles": {
          "number": { "value": 80, "density": { "enable": true, "value_area": 800 } },
          "color": { "value": "#000000" },
          "shape": { "type": "circle" },
          "opacity": { "value": 0.5 },
          "size": { "value": 3, "random": true },
          "line_linked": {
            "enable": true,
            "distance": 150,
            "color": "#000000",
            "opacity": 0.4,
            "width": 1
          },
          "move": { "enable": true, "speed": 2 }
        },
        "interactivity": {
          "detect_on": "canvas",
          "events": {
            "onhover": { "enable": true, "mode": "repulse" },
            "onclick": { "enable": true, "mode": "push" }
          },
          "modes": {
            "repulse": { "distance": 100, "duration": 0.4 },
            "push": { "particles_nb": 4 }
          }
        },
        "retina_detect": true
      });
    </script>
    <!-- Main Application Script using Babel -->
    <script type="text/babel">
      const { useState, useEffect, useRef } = React;
      const { Canvas } = ReactThreeFiber;
      const { Button, Dialog, DialogActions, DialogContent, DialogTitle } = MaterialUI;
      
      // --- 3D Table Component using React Three Fiber ---
      const Table3D = () => {
        // Create a simple circular table with lighting.
        return (
          <>
            <ambientLight intensity={0.5} />
            <pointLight position={[10, 10, 10]} intensity={1} />
            <mesh rotation={[-Math.PI / 2, 0, 0]}>
              <circleGeometry args={[5, 64]} />
              <meshStandardMaterial color="#006400" />
            </mesh>
          </>
        );
      };
      
      // --- Helper Functions ---
      const suits = ['♠', '♥', '♦', '♣'];
      const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
      const createDeck = () => {
        let deck = [];
        suits.forEach(suit => {
          ranks.forEach(rank => {
            deck.push({ rank, suit });
          });
        });
        return deck;
      };
      const shuffleDeck = (deck) => {
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
      };
      
      // Format card for PokerSolver (10 becomes T)
      const formatCardForSolver = (card) => {
        let rank = card.rank === "10" ? "T" : card.rank;
        const suitMap = { '♠': 's', '♥': 'h', '♦': 'd', '♣': 'c' };
        return `${rank}${suitMap[card.suit]}`;
      };
      
      // Card Component for 2D UI
      const Card2D = ({ card, reveal }) => {
        // If not revealed (for opponents) show a blank card (e.g., "?" instead)
        return (
          <div className="card animate-bounce">
            <div className="card-inner">
              <div className="card-face card-front">
                {reveal ? `${card.rank}${card.suit}` : "?"}
              </div>
            </div>
          </div>
        );
      };
      
      // --- Smarter AI Simulation ---
      const aiDecision = async (playerHand, community) => {
        const highRanks = ["J", "Q", "K", "A"];
        const countHigh = (cards) => cards.filter(c => highRanks.includes(c.rank)).length;
        let highCount = countHigh(playerHand) + countHigh(community);
        await new Promise(res => setTimeout(res, 500));
        if (highCount >= 3) return "raise";
        if (highCount === 0) return "fold";
        return "call";
      };
      
      // --- Main Poker Game Component ---
      const PokerGameComponent = () => {
        const numPlayers = 4;
        const initialBalance = 1000;
        const bigBlindAmt = 50;
        const smallBlindAmt = 25;
        const moveTime = 30; // seconds per move
        
        // Game state
        const [deck, setDeck] = useState([]);
        const [players, setPlayers] = useState({});
        const [community, setCommunity] = useState([]);
        const [stage, setStage] = useState("pre-flop");
        const [pot, setPot] = useState(0);
        const [currentPlayer, setCurrentPlayer] = useState(1);
        const [message, setMessage] = useState("");
        const [processing, setProcessing] = useState(false);
        const [handCount, setHandCount] = useState(0);
        const [timer, setTimer] = useState(moveTime);
        const timerRef = useRef(null);
        const [newGameDialog, setNewGameDialog] = useState(false);
        
        // Reset timer on currentPlayer change
        useEffect(() => {
          resetTimer();
          return () => clearInterval(timerRef.current);
        }, [currentPlayer]);
        
        const resetTimer = () => {
          clearInterval(timerRef.current);
          setTimer(moveTime);
          timerRef.current = setInterval(() => {
            setTimer(prev => {
              if(prev <= 1) {
                clearInterval(timerRef.current);
                if(currentPlayer === 1) handlePlayerAction("call");
                return moveTime;
              }
              return prev - 1;
            });
          }, 1000);
        };
        
        // Initialize a new hand (round)
        const initHand = () => {
          let newDeck = shuffleDeck(createDeck());
          let newPlayers = {};
          for (let i = 1; i <= numPlayers; i++) {
            let balance = players[i] ? players[i].balance : initialBalance;
            newPlayers[i] = {
              hand: [newDeck.pop(), newDeck.pop()],
              balance: balance,
              active: true,
              bet: 0,
              totalBet: 0
            };
          }
          // Post blinds: player2 posts small, player3 posts big.
          newPlayers[2].balance -= smallBlindAmt;
          newPlayers[2].bet = smallBlindAmt;
          newPlayers[2].totalBet = smallBlindAmt;
          newPlayers[3].balance -= bigBlindAmt;
          newPlayers[3].bet = bigBlindAmt;
          newPlayers[3].totalBet = bigBlindAmt;
          setPot(smallBlindAmt + bigBlindAmt);
          setDeck(newDeck);
          setPlayers(newPlayers);
          setCommunity([]);
          setStage("pre-flop");
          setCurrentPlayer(4);
          setMessage("Pre-flop: Your move if you're Player 1.");
          setHandCount(prev => prev + 1);
        };
        
        // Initialize a new game (reset balances and hand count)
        const initGame = () => {
          let newPlayers = {};
          for (let i = 1; i <= numPlayers; i++) {
            newPlayers[i] = { balance: initialBalance };
          }
          setPlayers(newPlayers);
          setHandCount(0);
          initHand();
        };
        
        useEffect(() => {
          initGame();
        }, []);
        
        // Deal community cards.
        const dealCommunity = (count) => {
          let newDeck = [...deck];
          let newCommunity = [...community];
          for (let i = 0; i < count; i++) {
            newCommunity.push(newDeck.pop());
          }
          setDeck(newDeck);
          setCommunity(newCommunity);
          if(newCommunity.length === 3) setStage("flop");
          else if(newCommunity.length === 4) setStage("turn");
          else if(newCommunity.length === 5) setStage("river");
        };
        
        // Get current bet.
        const currentBet = () => {
          let maxBet = 0;
          Object.values(players).forEach(p => {
            if(p.bet > maxBet) maxBet = p.bet;
          });
          return maxBet;
        };
        
        // Process bet action.
        const processBet = async (action, playerId, raiseAmt = 0) => {
          let newPlayers = { ...players };
          if(action === "fold") {
            newPlayers[playerId].active = false;
            setMessage(`Player ${playerId} folds.`);
          } else if(action === "call") {
            let betNeeded = currentBet() - newPlayers[playerId].bet;
            if(newPlayers[playerId].balance >= betNeeded) {
              newPlayers[playerId].balance -= betNeeded;
              newPlayers[playerId].bet += betNeeded;
              newPlayers[playerId].totalBet += betNeeded;
              setPot(prev => prev + betNeeded);
              setMessage(`Player ${playerId} calls.`);
            }
          } else if(action === "raise") {
            if(newPlayers[playerId].balance >= raiseAmt) {
              newPlayers[playerId].balance -= raiseAmt;
              newPlayers[playerId].bet += raiseAmt;
              newPlayers[playerId].totalBet += raiseAmt;
              setPot(prev => prev + raiseAmt);
              setMessage(`Player ${playerId} raises by ${raiseAmt}.`);
            }
          } else if(action === "check") {
            setMessage(`Player ${playerId} checks.`);
          }
          setPlayers(newPlayers);
        };
        
        // Check if betting round is over.
        const bettingRoundOver = () => {
          const activePlayers = Object.entries(players)
            .filter(([pid, p]) => p.active)
            .map(([pid, p]) => p);
          return activePlayers.every(p => p.bet === currentBet());
        };
        
        // Evaluate hands using PokerSolver.
        const evaluateHands = () => {
          let bestHand = null;
          let winner = null;
          for (let pid in players) {
            if (!players[pid].active) continue;
            let hole = players[pid].hand.map(c => formatCardForSolver(c));
            let communityCards = community.map(c => formatCardForSolver(c));
            const solved = PokerSolver.Hand.solve([...hole, ...communityCards]);
            if (!bestHand || solved.rank < bestHand.rank) {
              bestHand = solved;
              winner = pid;
            }
          }
          return winner;
        };
        
        // Advance stage.
        const nextStage = async () => {
          let newPlayers = { ...players };
          for(let pid in newPlayers) { newPlayers[pid].bet = 0; }
          setPlayers(newPlayers);
          if(stage === "pre-flop") { dealCommunity(3); }
          else if(stage === "flop") { dealCommunity(1); }
          else if(stage === "turn") { dealCommunity(1); }
          setMessage(`Stage: ${stage.toUpperCase()}`);
          resetTimer();
        };
        
        // CPU actions.
        const runCpuActions = async () => {
          for(let pid = 2; pid <= numPlayers; pid++) {
            if (!players[pid].active) continue;
            setProcessing(true);
            const decision = await aiDecision(players[pid].hand, community);
            if(decision === "raise") {
              let raiseAmt = Math.floor(Math.random() * 150) + 50;
              await processBet("raise", pid, raiseAmt);
            } else {
              await processBet(decision, pid);
            }
            setProcessing(false);
          }
        };
        
        // Handle human action.
        const handlePlayerAction = async (action, raiseAmt = 0) => {
          if (!players[1].active) return;
          await processBet(action, 1, raiseAmt);
          await runCpuActions();
          if (bettingRoundOver()) {
            if (stage === "river") {
              // Evaluate hand.
              setMessage("Showdown!");
              const winner = evaluateHands();
              let newPlayers = { ...players };
              newPlayers[winner].balance += pot;
              setPlayers(newPlayers);
              setMessage(`Showdown! Player ${winner} wins the pot of ${pot} credits!`);
              setTimeout(() => { initHand(); }, 3000);
              if (players[1].balance <= 0) {
                setTimeout(() => {
                  setNewGameDialog(true);
                }, 3000);
              }
            } else {
              await nextStage();
            }
          }
          resetTimer();
        };
        
        // "New Game" resets the overall game.
        const newGame = () => {
          if (window.confirm("Start a new game? All progress will be reset.")) {
            initGame();
          }
        };
        
        // Update stats display.
        useEffect(() => {
          const statsElem = document.getElementById("stats");
          if (statsElem) statsElem.textContent = `Hands: ${handCount}`;
        }, [handCount]);
        
        // Highlight current player (for demo, we simulate currentPlayer changes)
        // In a real game, you'd setCurrentPlayer based on betting order.
        
        return (
          <>
            {/* 3D Table rendered via React Three Fiber */}
            <Canvas className="table3D">
              <Table3D />
            </Canvas>
            {/* Overlay 2D UI */}
            <div className="game-ui">
              <div className="info">
                Stage: {stage.toUpperCase()} | POT: {pot} | Blinds: SB {smallBlindAmt} / BB {bigBlindAmt}
              </div>
              <div className="community">
                {community.map((card, idx) => (
                  <Card2D key={idx} card={card} reveal={true} />
                ))}
              </div>
              {Object.entries(players).map(([pid, data]) => (
                <div key={pid} className={`player p${pid} ${currentPlayer == pid ? "active" : ""}`}>
                  <div>Player {pid} {pid === "1" && "(You)"}</div>
                  <div style={{ display: 'flex', gap: '5px', justifyContent: 'center' }}>
                    {data.hand.map((card, idx) => (
                      <Card2D key={idx} card={ (pid === "1" || stage === "river") ? card : { rank: "?", suit: "?" } } reveal={ (pid === "1" || stage === "river") } />
                    ))}
                  </div>
                  <div>
                    Balance: {data.balance} | Bet: {data.totalBet}
                  </div>
                </div>
              ))}
              <div className="controls">
                <button className="btn-fold" onClick={() => handlePlayerAction("fold")} disabled={processing}>Fold</button>
                <button className="btn-call" onClick={() => handlePlayerAction("call")} disabled={processing}>Call/Check</button>
                <button className="btn-raise" onClick={() => {
                  const amt = parseInt(prompt("Enter raise amount:", "100")) || 100;
                  handlePlayerAction("raise", amt);
                }} disabled={processing}>Raise</button>
                {stage !== "river" && (
                  <button className="btn-next" onClick={nextStage} disabled={processing}>Next Stage</button>
                )}
                {stage === "river" && (
                  <button className="btn-showdown" onClick={async () => {
                    await runCpuActions();
                    const winner = evaluateHands();
                    setMessage(`Showdown! Player ${winner} wins the pot of ${pot} credits!`);
                  }} disabled={processing}>Showdown</button>
                )}
                <button className="btn-new" onClick={newGame}>New Game</button>
              </div>
              {message && (
                <div className="game-info">{message}</div>
              )}
            </div>
            {/* Dialog for new game prompt */}
            <Dialog open={newGameDialog} onClose={() => setNewGameDialog(false)}>
              <DialogTitle>{"LOZER!! You ran out of points."}</DialogTitle>
              <DialogContent>
                Start a new game?
              </DialogContent>
              <DialogActions>
                <Button onClick={() => { setNewGameDialog(false); newGame(); }} color="primary">
                  Yes
                </Button>
                <Button onClick={() => setNewGameDialog(false)} color="secondary" autoFocus>
                  No
                </Button>
              </DialogActions>
            </Dialog>
          </>
        );
      };
      
      // Simple Card2D component for UI overlay.
      const Card2D = ({ card, reveal }) => {
        return (
          <div className="card animate-bounce">
            <div className="card-inner">
              <div className="card-face card-front">
                {reveal ? `${card.rank}${card.suit}` : "?"}
              </div>
            </div>
          </div>
        );
      };
      
      ReactDOM.render(<PokerGameComponent />, document.getElementById('root'));
    </script>
  </body>
</html>
