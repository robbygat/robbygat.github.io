<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Texas Hold'em Poker</title>
    <!-- Google Fonts -->
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <!-- Font Awesome for icons -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <!-- particles.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <!-- PokerSolver library for hand evaluation -->
    <script src="https://unpkg.com/pokersolver@2.2.0/dist/pokersolver.min.js"></script>
    <!-- React and Babel CDN -->
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      /* (Same CSS as before – not repeated here for brevity) */
      /* ... */
    </style>
  </head>
  <body>
    <!-- Particles background, header, timer, stats, ledger, etc. (Same UI as before) -->
    <!-- ... -->
    <!-- Main React Root -->
    <div id="root"></div>
    <!-- particles.js configuration -->
    <script>
      particlesJS("particles-js", {
        "particles": {
          "number": { "value": 80, "density": { "enable": true, "value_area": 800 } },
          "color": { "value": "#000000" },
          "shape": { "type": "circle" },
          "opacity": { "value": 0.5 },
          "size": { "value": 3, "random": true },
          "line_linked": {
            "enable": true,
            "distance": 150,
            "color": "#000000",
            "opacity": 0.4,
            "width": 1
          },
          "move": { "enable": true, "speed": 2 }
        },
        "interactivity": {
          "detect_on": "canvas",
          "events": {
            "onhover": { "enable": true, "mode": "repulse" },
            "onclick": { "enable": true, "mode": "push" }
          },
          "modes": {
            "repulse": { "distance": 100, "duration": 0.4 },
            "push": { "particles_nb": 4 }
          }
        },
        "retina_detect": true
      });
    </script>
    <!-- Sound Effects and Background Music (calming vaporwave synth) -->
    <audio id="sound-bet" src="https://actions.google.com/sounds/v1/alarms/bugle_tune.ogg"></audio>
    <audio id="sound-showdown" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg"></audio>
    <audio id="sound-newhand" src="https://actions.google.com/sounds/v1/alarms/double_beep.ogg"></audio>
    <audio id="background-music" src="https://actions.google.com/sounds/v1/ambiences/vaporwave_loop.ogg" loop></audio>
    <script>
      const volumeSlider = document.getElementById("volume-slider");
      const setVolumeAll = (vol) => {
        const sounds = document.querySelectorAll("audio");
        sounds.forEach(sound => sound.volume = vol);
      };
      volumeSlider.addEventListener("input", (e) => {
        setVolumeAll(e.target.value);
      });
      document.getElementById("background-music").play();
    </script>
    <script type="text/babel">
      const { useState, useEffect, useRef } = React;
      
      // --- Helper Functions (Logic) ---
      const suits = ['♠', '♥', '♦', '♣'];
      const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
      // Create a standard 52-card deck.
      const createDeck = () => {
        let deck = [];
        suits.forEach(suit => {
          ranks.forEach(rank => {
            deck.push({ rank, suit });
          });
        });
        return deck;
      };
      const shuffleDeck = (deck) => {
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
      };
      // Format a card for PokerSolver.
      const formatCardForSolver = (card) => {
        let rank = card.rank === "10" ? "T" : card.rank;
        const suitMap = { '♠': 's', '♥': 'h', '♦': 'd', '♣': 'c' };
        return `${rank}${suitMap[card.suit]}`;
      };
      
      // Card Component (unchanged UI).
      const Card = ({ card, animate }) => {
        let faceClass = "card-front";
        if (card.suit === '♥' || card.suit === '♦') faceClass += " red";
        else if (card.suit === "?") faceClass = "card-front"; // hidden cards will be styled with the "hidden" class.
        else faceClass += " black";
        const hiddenClass = card.suit === "?" ? "hidden" : "";
        return (
          <div className={`card animate-bounce ${animate ? "flip" : ""} ${hiddenClass}`}>
            <div className="card-inner">
              <div className={`card-face card-front ${faceClass}`}>
                {card.suit === "?" ? "" : `${card.rank}${card.suit}`}
              </div>
            </div>
          </div>
        );
      };
      
      // --- New Logic: Dealer and Turn Order ---
      // nextPlayer: returns next active player's id in clockwise order.
      const nextPlayer = (current, players) => {
        let next = current;
        do {
          next = (next % Object.keys(players).length) + 1;
        } while (!players[next].active && next !== current);
        return next;
      };
      
      // --- Advanced AI Simulation Placeholder ---
      const aiDecision = async (playerHand, community) => {
        const highRanks = ["J", "Q", "K", "A"];
        const countHigh = (cards) => cards.filter(c => highRanks.includes(c.rank)).length;
        let highCount = countHigh(playerHand) + countHigh(community);
        await new Promise(res => setTimeout(res, 500));
        if (highCount >= 3) return "raise";
        if (highCount === 0) return "fold";
        return "call";
      };
      
      // --- Ledger Management ---
      const updateLedger = (handCount, players) => {
        const ledgerBody = document.getElementById("ledger-body");
        if (!ledgerBody) return;
        const row = document.createElement("tr");
        const handCell = document.createElement("td");
        handCell.textContent = handCount;
        row.appendChild(handCell);
        for (let i = 1; i <= 4; i++) {
          const cell = document.createElement("td");
          cell.textContent = players[i] ? players[i].balance : 0;
          row.appendChild(cell);
        }
        ledgerBody.appendChild(row);
      };
      
      // --- Sound Effects Helper ---
      const playSound = (id) => {
        const sound = document.getElementById(id);
        if (sound) {
          sound.currentTime = 0;
          sound.play();
        }
      };
      
      // --- Poker Game Component (Logic Updates Only) ---
      const PokerGameComponent = () => {
        const numPlayers = 4;
        const initialBalance = 1000;
        const bigBlindAmt = 50;
        const smallBlindAmt = 25;
        const moveTime = 30; // seconds per move
        
        // Added new states: dealer, smallBlindPos, bigBlindPos.
        const [dealer, setDealer] = useState(1);
        
        // Game state
        const [deck, setDeck] = useState([]);
        const [players, setPlayers] = useState({});
        const [community, setCommunity] = useState([]);
        const [stage, setStage] = useState("pre-flop");
        const [pot, setPot] = useState(0);
        const [currentPlayer, setCurrentPlayer] = useState(1);
        const [message, setMessage] = useState("");
        const [processing, setProcessing] = useState(false);
        const [handCount, setHandCount] = useState(0);
        const [timer, setTimer] = useState(moveTime);
        const timerRef = useRef(null);
        
        // Update turn indicator.
        const updateTurnIndicator = () => {
          const turnElem = document.getElementById("turn");
          if (turnElem) turnElem.textContent = `Turn: Player ${currentPlayer}`;
        };
        
        // Reset timer when currentPlayer changes.
        useEffect(() => {
          resetTimer();
          updateTurnIndicator();
          return () => clearInterval(timerRef.current);
        }, [currentPlayer]);
        
        const resetTimer = () => {
          clearInterval(timerRef.current);
          setTimer(moveTime);
          timerRef.current = setInterval(() => {
            setTimer(prev => {
              if (prev <= 1) {
                clearInterval(timerRef.current);
                if (currentPlayer === 1) handlePlayerAction("call");
                return moveTime;
              }
              return prev - 1;
            });
          }, 1000);
        };
        
        // Initialize a new hand.
        const initHand = () => {
          let newDeck = shuffleDeck(createDeck());
          let newPlayers = {};
          for (let i = 1; i <= numPlayers; i++) {
            let balance = players[i] ? players[i].balance : initialBalance;
            newPlayers[i] = {
              hand: [newDeck.pop(), newDeck.pop()],
              balance: balance,
              active: true,
              bet: 0,
              totalBet: 0
            };
          }
          // Rotate dealer.
          const newDealer = (dealer % numPlayers) + 1;
          setDealer(newDealer);
          // Determine blinds using next active players.
          const smallBlindPos = nextPlayer(newDealer, newPlayers);
          const bigBlindPos = nextPlayer(smallBlindPos, newPlayers);
          newPlayers[smallBlindPos].balance -= smallBlindAmt;
          newPlayers[smallBlindPos].bet = smallBlindAmt;
          newPlayers[smallBlindPos].totalBet = smallBlindAmt;
          newPlayers[bigBlindPos].balance -= bigBlindAmt;
          newPlayers[bigBlindPos].bet = bigBlindAmt;
          newPlayers[bigBlindPos].totalBet = bigBlindAmt;
          setPot(smallBlindAmt + bigBlindAmt);
          setDeck(newDeck);
          setPlayers(newPlayers);
          setCommunity([]);
          setStage("pre-flop");
          // Pre-flop action starts with player after big blind.
          setCurrentPlayer(nextPlayer(bigBlindPos, newPlayers));
          setMessage("Pre-flop: Your move if you're Player 1.");
          setHandCount(prev => prev + 1);
          playSound("sound-newhand");
          if (handCount > 0) updateLedger(handCount + 1, players);
        };
        
        // Initialize a new game.
        const initGame = () => {
          let newPlayers = {};
          for (let i = 1; i <= numPlayers; i++) {
            newPlayers[i] = { balance: initialBalance };
          }
          setPlayers(newPlayers);
          setHandCount(0);
          const ledgerBody = document.getElementById("ledger-body");
          if (ledgerBody) ledgerBody.innerHTML = "";
          initHand();
        };
        
        useEffect(() => {
          initGame();
        }, []);
        
        // Deal community cards.
        const dealCommunity = (count) => {
          let newDeck = [...deck];
          let newCommunity = [...community];
          for (let i = 0; i < count; i++) {
            newCommunity.push(newDeck.pop());
          }
          setDeck(newDeck);
          setCommunity(newCommunity);
          if (newCommunity.length === 3) setStage("flop");
          else if (newCommunity.length === 4) setStage("turn");
          else if (newCommunity.length === 5) setStage("river");
        };
        
        // Get current bet.
        const currentBet = () => {
          let maxBet = 0;
          Object.values(players).forEach(p => {
            if (p.bet > maxBet) maxBet = p.bet;
          });
          return maxBet;
        };
        
        // Process a bet action.
        const processBet = async (action, playerId, raiseAmt = 0) => {
          let newPlayers = { ...players };
          if (action === "fold") {
            newPlayers[playerId].active = false;
            setMessage(`Player ${playerId} folds.`);
          } else if (action === "call") {
            let betNeeded = currentBet() - newPlayers[playerId].bet;
            if (newPlayers[playerId].balance >= betNeeded) {
              newPlayers[playerId].balance -= betNeeded;
              newPlayers[playerId].bet += betNeeded;
              newPlayers[playerId].totalBet += betNeeded;
              setPot(prev => prev + betNeeded);
              setMessage(`Player ${playerId} calls.`);
              playSound("sound-bet");
            }
          } else if (action === "raise") {
            if (newPlayers[playerId].balance >= raiseAmt) {
              newPlayers[playerId].balance -= raiseAmt;
              newPlayers[playerId].bet += raiseAmt;
              newPlayers[playerId].totalBet += raiseAmt;
              setPot(prev => prev + raiseAmt);
              setMessage(`Player ${playerId} raises by ${raiseAmt}.`);
              playSound("sound-bet");
            }
          } else if (action === "check") {
            setMessage(`Player ${playerId} checks.`);
          }
          setPlayers(newPlayers);
        };
        
        // Check if betting round is over.
        const bettingRoundOver = () => {
          const activePlayers = Object.entries(players)
            .filter(([pid, p]) => p.active)
            .map(([pid, p]) => p);
          return activePlayers.every(p => p.bet === currentBet());
        };
        
        // Evaluate hands using PokerSolver at showdown.
        const evaluateHands = () => {
          let bestScore = null;
          let winners = [];
          for (let pid in players) {
            if (!players[pid].active) continue;
            let hole = players[pid].hand.map(c => formatCardForSolver(c));
            let communityCards = community.map(c => formatCardForSolver(c));
            const solved = PokerSolver.Hand.solve([...hole, ...communityCards]);
            if (bestScore === null || solved.rank < bestScore.rank) {
              bestScore = solved;
              winners = [pid];
            } else if (solved.rank === bestScore.rank) {
              winners.push(pid);
            }
          }
          // For simplicity, if multiple winners, award full pot to the first (or split equally).
          return winners.length === 1 ? winners[0] : winners;
        };
        
        // Advance to next stage.
        const nextStage = async () => {
          let newPlayers = { ...players };
          for (let pid in newPlayers) {
            newPlayers[pid].bet = 0;
          }
          setPlayers(newPlayers);
          if (stage === "pre-flop") {
            dealCommunity(3); // flop.
            // Post-flop action starts with the player after the dealer.
            setCurrentPlayer(nextPlayer(dealer, newPlayers));
          } else if (stage === "flop") {
            dealCommunity(1); // turn.
            setCurrentPlayer(nextPlayer(dealer, newPlayers));
          } else if (stage === "turn") {
            dealCommunity(1); // river.
            setCurrentPlayer(nextPlayer(dealer, newPlayers));
          }
          setMessage(`Stage: ${stage.toUpperCase()}`);
          resetTimer();
        };
        
        // CPU actions.
        const runCpuActions = async () => {
          for (let pid = 2; pid <= numPlayers; pid++) {
            if (!players[pid].active) continue;
            setProcessing(true);
            const decision = await aiDecision(players[pid].hand, community);
            if (decision === "raise") {
              let raiseAmt = Math.floor(Math.random() * 150) + 50;
              await processBet("raise", pid, raiseAmt);
            } else {
              await processBet(decision, pid);
            }
            setProcessing(false);
          }
        };
        
        // Handle human (player 1) action.
        const handlePlayerAction = async (action, raiseAmt = 0) => {
          if (!players[1].active) return;
          // Enforce that if a bet exists, you must call at least.
          if (action === "raise" && players[1].bet < currentBet()) {
            alert("You must first call the current bet to stay in the hand.");
            return;
          }
          await processBet(action, 1, raiseAmt);
          // After human action, set turn to next active CPU.
          setCurrentPlayer(nextPlayer(1, players));
          await runCpuActions();
          if (bettingRoundOver()) {
            if (stage === "river") {
              setMessage("Showdown!");
              playSound("sound-showdown");
              const result = evaluateHands();
              // If multiple winners, split pot evenly.
              if (Array.isArray(result)) {
                let split = Math.floor(pot / result.length);
                let newPlayers = { ...players };
                result.forEach(winner => { newPlayers[winner].balance += split; });
                setPlayers(newPlayers);
                window.alert(`Showdown! Players ${result.join(", ")} split the pot of ${pot} credits!`);
                setMessage(`Showdown! Players ${result.join(", ")} split the pot of ${pot} credits!`);
              } else {
                let newPlayers = { ...players };
                newPlayers[result].balance += pot;
                setPlayers(newPlayers);
                window.alert(`Showdown! Player ${result} wins the pot of ${pot} credits!`);
                setMessage(`Showdown! Player ${result} wins the pot of ${pot} credits!`);
              }
              setTimeout(() => { initHand(); }, 3000);
              if (players[1].balance <= 0) {
                setTimeout(() => {
                  if (window.confirm("LOZER!! You ran out of points. Start a new game?")) {
                    initGame();
                  }
                }, 3000);
              }
            } else {
              await nextStage();
            }
          }
          resetTimer();
          // Cycle turn (for demo: simple cycle).
          setCurrentPlayer(prev => nextPlayer(prev, players));
        };
        
        // "New Game" button.
        const newGame = () => {
          if (window.confirm("Start a new game? All progress will be reset.")) {
            initGame();
          }
        };
        
        // Update game stats (hand counter).
        useEffect(() => {
          const statsElem = document.getElementById("stats");
          if (statsElem) statsElem.textContent = `Hands: ${handCount}`;
        }, [handCount]);
        
        return (
          <div className="table">
            <div className="info">
              Stage: {stage.toUpperCase()} | POT: {pot} | Blinds: SB {smallBlindAmt} / BB {bigBlindAmt} | Dealer: Player {dealer}
            </div>
            <div className="community">
              {community.map((card, idx) => (
                <Card key={idx} card={card} animate={true} />
              ))}
            </div>
            {Object.entries(players).map(([pid, data]) => (
              <div key={pid} className={`player p${pid} ${currentPlayer == pid ? "active" : ""}`}>
                <div>Player {pid} {pid === "1" && "(You)"}</div>
                <div style={{ display: 'flex', gap: '5px', justifyContent: 'center' }}>
                  {data.hand.map((card, idx) => (
                    // For CPU players, show hidden cards (blue "??") until showdown.
                    <Card key={idx} card={(pid === "1" || stage === "river") ? card : { rank: "?", suit: "?" }} animate={true} />
                  ))}
                </div>
                <div>
                  Balance: {data.balance} | Bet: {data.totalBet}
                </div>
              </div>
            ))}
            <div className="controls">
              <button className="btn-fold" onClick={() => handlePlayerAction("fold")} disabled={processing}>Fold</button>
              <button className="btn-call" onClick={() => handlePlayerAction("call")} disabled={processing}>Call/Check</button>
              <button className="btn-raise" onClick={() => {
                const amt = parseInt(prompt("Enter raise amount:", "100")) || 100;
                handlePlayerAction("raise", amt);
              }} disabled={processing}>Raise</button>
              {stage !== "river" && (
                <button className="btn-next" onClick={nextStage} disabled={processing}>Next Stage</button>
              )}
              {stage === "river" && (
                <button className="btn-showdown" onClick={async () => {
                  await runCpuActions();
                  const result = evaluateHands();
                  if (Array.isArray(result)) {
                    let split = Math.floor(pot / result.length);
                    let newPlayers = { ...players };
                    result.forEach(winner => { newPlayers[winner].balance += split; });
                    setPlayers(newPlayers);
                    window.alert(`Showdown! Players ${result.join(", ")} split the pot of ${pot} credits!`);
                    setMessage(`Showdown! Players ${result.join(", ")} split the pot of ${pot} credits!`);
                  } else {
                    let newPlayers = { ...players };
                    newPlayers[result].balance += pot;
                    setPlayers(newPlayers);
                    window.alert(`Showdown! Player ${result} wins the pot of ${pot} credits!`);
                    setMessage(`Showdown! Player ${result} wins the pot of ${pot} credits!`);
                  }
                }} disabled={processing}>Showdown</button>
              )}
              <button className="btn-new" onClick={newGame}>New Game</button>
            </div>
            {message && (
              <div className="game-info">
                {message}
              </div>
            )}
          </div>
        );
      };
      
      // Placeholder: For real-time multiplayer and advanced AI, integrate a backend with websockets and ML.
      
      ReactDOM.render(<PokerGameComponent />, document.getElementById('root'));
    </script>
  </body>
</html>
