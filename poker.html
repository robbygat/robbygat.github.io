<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Texas Hold'em Poker</title>
    <!-- Google Fonts -->
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <!-- Font Awesome for icons -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <!-- particles.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <!-- React and Babel -->
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      /* Reset & Variables */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      :root {
        --primary-color: #ffffff;
        --accent-color: #ff4081;
        --poker-green: #35654d;
        --font-family: 'Roboto', sans-serif;
      }
      body {
        font-family: var(--font-family);
        background-color: var(--poker-green);
        color: var(--primary-color);
        overflow-x: hidden;
      }
      /* Particles container */
      #particles-js {
        position: fixed;
        width: 100%;
        height: 100%;
        z-index: -2;
        background-color: var(--poker-green);
      }
      /* Header */
      header {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 20px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.8);
        position: sticky;
        top: 0;
        z-index: 1000;
      }
      header a,
      header button {
        font-size: 1.2rem;
        color: var(--primary-color);
        background: none;
        border: none;
        cursor: pointer;
        text-decoration: none;
        transition: transform 0.3s;
      }
      header a:hover,
      header button:hover {
        transform: scale(1.2);
        color: var(--accent-color);
      }
      /* Table Background */
      .table {
        position: relative;
        width: 100%;
        min-height: 100vh;
        background: url('table.png') no-repeat center center;
        background-size: cover;
      }
      .fallback-table {
        position: absolute;
        top: 50px;
        left: 50px;
        right: 50px;
        bottom: 50px;
        border: 10px solid darkgreen;
        border-radius: 50%;
        background: seagreen;
      }
      /* Info text */
      .info {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 1.5rem;
        font-weight: bold;
        z-index: 1;
      }
      /* Community Cards */
      .community {
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        z-index: 1;
      }
      /* Player Areas */
      .player {
        position: absolute;
        text-align: center;
        z-index: 1;
      }
      .player.p1 { top: 70%; left: 45%; }
      .player.p2 { top: 40%; left: 10%; }
      .player.p3 { top: 10%; left: 45%; }
      .player.p4 { top: 40%; left: 80%; }
      /* Card Container with Flip Animation */
      .card-container {
        perspective: 1000px;
        width: 90px;
        height: 135px;
      }
      .card {
        width: 100%;
        height: 100%;
        border: 2px solid #fff;
        border-radius: 8px;
        position: absolute;
        backface-visibility: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        transition: transform 0.6s;
      }
      .card.front {
        background: #fff;
      }
      .card.back {
        background: darkblue;
        color: #fff;
        transform: rotateY(180deg);
        font-size: 2.5rem;
        font-weight: bold;
      }
      .flip .card.front {
        transform: rotateY(180deg);
      }
      .flip .card.back {
        transform: rotateY(360deg);
      }
      /* Controls */
      .controls {
        position: absolute;
        bottom: 0;
        width: 100%;
        background: #222;
        padding: 15px;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
        z-index: 1;
      }
      .controls button {
        font-size: 1rem;
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }
      .btn-fold { background: #d9534f; color: #fff; }
      .btn-call { background: #5cb85c; color: #fff; }
      .btn-raise { background: #0275d8; color: #fff; }
      .btn-next { background: #888; color: #fff; }
      .btn-showdown { background: #ff9900; color: #fff; }
      .btn-new { background: #ff9900; color: #000; }
      /* Timer display */
      .timer {
        font-size: 1.2rem;
        margin-left: 15px;
        color: #ff4081;
      }
      /* Responsive adjustments */
      @media (max-width: 600px) {
        .info { font-size: 1.2rem; }
        header a, header button { font-size: 1rem; }
        .controls button { font-size: 0.9rem; padding: 8px 15px; }
      }
    </style>
  </head>
  <body>
    <!-- Particles Background -->
    <div id="particles-js"></div>
    <!-- Header with Home button -->
    <header>
      <a href="index.html" aria-label="Home"><i class="fas fa-home"></i> Home</a>
      <h2>Poker Arena</h2>
    </header>
    <!-- Main React Root -->
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useEffect, useRef } = React;
      
      // --- Helper Functions ---
      const suits = ['♠', '♥', '♦', '♣'];
      const ranks = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
      
      const createDeck = () => {
        let deck = [];
        suits.forEach(suit => {
          ranks.forEach(rank => {
            deck.push({ rank, suit });
          });
        });
        return deck;
      };
      const shuffleDeck = (deck) => {
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
      };
      
      // Render a card with flip animation.
      // For face-up cards, set color based on suit:
      // Hearts/diamonds = red; clubs/spades = black.
      const Card = ({ card, faceUp, flip }) => {
        const isRed = card && (card.suit === '♥' || card.suit === '♦');
        return (
          <div className={`card-container ${flip ? 'flip' : ''}`}>
            <div className="card front" style={{ color: isRed ? 'red' : 'black' }}>
              {card.rank}{card.suit}
            </div>
            <div className="card back">
              P
            </div>
          </div>
        );
      };
      
      // --- AI Simulation ---
      const aiDecision = async (playerHand, community) => {
        await new Promise(res => setTimeout(res, 500));
        const choices = ['call', 'raise', 'fold', 'check'];
        return choices[Math.floor(Math.random() * choices.length)];
      };
      
      // --- Poker Game Component ---
      const PokerGameComponent = () => {
        const numPlayers = 4;
        const initialBalance = 1000;
        const bigBlindAmt = 50;
        const smallBlindAmt = 25;
        
        const [deck, setDeck] = useState([]);
        const [players, setPlayers] = useState({});
        const [community, setCommunity] = useState([]);
        const [stage, setStage] = useState("pre-flop");
        const [pot, setPot] = useState(0);
        const [currentPlayer, setCurrentPlayer] = useState(1);
        const [message, setMessage] = useState("");
        const [processing, setProcessing] = useState(false);
        const [timer, setTimer] = useState(30);
        const timerRef = useRef(null);
        
        // Start a new game (new hand)
        const initGame = () => {
          let newDeck = shuffleDeck(createDeck());
          let newPlayers = {};
          for (let i = 1; i <= numPlayers; i++) {
            newPlayers[i] = {
              hand: [newDeck.pop(), newDeck.pop()],
              balance: i === 1 ? players[1]?.balance || initialBalance : initialBalance,
              active: true,
              bet: 0
            };
          }
          // Post blinds (assume players 2 and 3 for demo)
          newPlayers[2].balance -= smallBlindAmt; newPlayers[2].bet = smallBlindAmt;
          newPlayers[3].balance -= bigBlindAmt; newPlayers[3].bet = bigBlindAmt;
          setPot(smallBlindAmt + bigBlindAmt);
          setDeck(newDeck);
          setPlayers(newPlayers);
          setCommunity([]);
          setStage("pre-flop");
          setCurrentPlayer(4); // action starts with player 4
          setMessage("Pre-flop: Your move if you're player 1.");
          resetTimer();
        };
        
        // Reset timer to 30 sec
        const resetTimer = () => {
          setTimer(30);
          if (timerRef.current) clearInterval(timerRef.current);
          timerRef.current = setInterval(() => {
            setTimer(prev => {
              if (prev <= 1) {
                clearInterval(timerRef.current);
                // Auto-call if time expires
                playerAction("call");
                return 30;
              }
              return prev - 1;
            });
          }, 1000);
        };
        
        useEffect(() => {
          initGame();
          return () => clearInterval(timerRef.current);
        }, []);
        
        const dealCommunity = (count) => {
          let newDeck = [...deck];
          let newCommunity = [...community];
          for (let i = 0; i < count; i++) {
            newCommunity.push(newDeck.pop());
          }
          setDeck(newDeck);
          setCommunity(newCommunity);
          if (newCommunity.length === 3) setStage("flop");
          else if (newCommunity.length === 4) setStage("turn");
          else if (newCommunity.length === 5) setStage("river");
          resetTimer();
        };
        
        const currentBet = () => {
          let maxBet = 0;
          Object.values(players).forEach(p => {
            if (p.bet > maxBet) maxBet = p.bet;
          });
          return maxBet;
        };
        
        const processBet = async (action, playerId, raiseAmt=0) => {
          let newPlayers = { ...players };
          if (action === "fold") {
            newPlayers[playerId].active = false;
            setMessage(`Player ${playerId} folds.`);
          } else if (action === "call") {
            const betNeeded = currentBet() - newPlayers[playerId].bet;
            if (newPlayers[playerId].balance >= betNeeded) {
              newPlayers[playerId].balance -= betNeeded;
              newPlayers[playerId].bet += betNeeded;
              setPot(pot + betNeeded);
              setMessage(`Player ${playerId} calls.`);
            }
          } else if (action === "raise") {
            if (newPlayers[playerId].balance >= raiseAmt) {
              newPlayers[playerId].balance -= raiseAmt;
              newPlayers[playerId].bet += raiseAmt;
              setPot(pot + raiseAmt);
              setMessage(`Player ${playerId} raises by ${raiseAmt}.`);
            }
          } else if (action === "check") {
            setMessage(`Player ${playerId} checks.`);
          }
          setPlayers(newPlayers);
        };
        
        const bettingRoundOver = () => {
          let active = Object.entries(players)
            .filter(([pid, p]) => p.active)
            .map(([pid, p]) => p);
          return active.every(p => p.bet === currentBet());
        };
        
        const nextStage = async () => {
          // Reset bets
          let newPlayers = { ...players };
          Object.keys(newPlayers).forEach(pid => newPlayers[pid].bet = 0);
          setPlayers(newPlayers);
          if (stage === "pre-flop") {
            dealCommunity(3);
          } else if (stage === "flop") {
            dealCommunity(1);
          } else if (stage === "turn") {
            dealCommunity(1);
          }
          setMessage(`Stage: ${stage.toUpperCase()}`);
        };
        
        // CPU actions
        const runCpuActions = async () => {
          for (let pid = 2; pid <= numPlayers; pid++) {
            if (!players[pid].active) continue;
            setProcessing(true);
            const decision = await aiDecision(players[pid].hand, community);
            if (decision === "raise") {
              let raiseAmt = Math.floor(Math.random() * 150) + 50;
              await processBet("raise", pid, raiseAmt);
            } else {
              await processBet(decision, pid);
            }
            setProcessing(false);
          }
        };
        
        const playerAction = async (action, raiseAmt=0) => {
          clearInterval(timerRef.current);
          await processBet(action, 1, raiseAmt);
          await runCpuActions();
          if (bettingRoundOver()) {
            if (stage === "river") {
              // Showdown: reveal all hands
              const active = Object.keys(players).filter(pid => players[pid].active);
              const winner = active[Math.floor(Math.random() * active.length)];
              setMessage(`Showdown! Player ${winner} wins the pot of ${pot} credits!`);
            } else {
              await nextStage();
            }
          }
          resetTimer();
          // If player 1 has 0 balance, prompt new game
          if (players[1] && players[1].balance <= 0) {
            setMessage("LOZER!! You've run out of credits. Start a new game?");
          }
        };
        
        // Render UI
        return (
          <div className="table">
            <div className="info">
              Stage: {stage.toUpperCase()} | POT: {pot} | Time: <span className="timer">{timer}s</span>
            </div>
            
            {/* Community Cards */}
            <div className="community">
              {community.map((card, idx) => (
                <Card key={idx} card={card} faceUp={true} flip={true} />
              ))}
            </div>
            
            {/* Players */}
            {Object.entries(players).map(([pid, data]) => (
              <div key={pid} className={`player p${pid}`}>
                <div>Player {pid} {pid == 1 && "(You)"}</div>
                <div style={{display: 'flex', gap: '5px', justifyContent: 'center'}}>
                  {data.hand.map((card, idx) => (
                    <Card
                      key={idx}
                      card={card}
                      faceUp={ pid === "1" || stage === "river" }
                      flip={true}
                    />
                  ))}
                </div>
                <div>Balance: {data.balance} | Bet: {data.bet}</div>
              </div>
            ))}
            
            {/* Controls */}
            <div className="controls">
              {players[1] && players[1].balance > 0 ? (
                <>
                  <button className="btn-fold" onClick={() => playerAction("fold")} disabled={processing}>Fold</button>
                  <button className="btn-call" onClick={() => playerAction("call")} disabled={processing}>Call/Check</button>
                  <button className="btn-raise" onClick={() => {
                    const amt = parseInt(prompt("Enter raise amount:", "100")) || 100;
                    playerAction("raise", amt);
                  }} disabled={processing}>Raise</button>
                  {stage !== "river" && (
                    <button className="btn-next" onClick={nextStage} disabled={processing}>Next Stage</button>
                  )}
                  {stage === "river" && (
                    <button className="btn-showdown" onClick={async () => {
                      await runCpuActions();
                      const active = Object.keys(players).filter(pid => players[pid].active);
                      const winner = active[Math.floor(Math.random() * active.length)];
                      setMessage(`Showdown! Player ${winner} wins the pot of ${pot} credits!`);
                    }} disabled={processing}>Showdown</button>
                  )}
                </>
              ) : (
                <button className="btn-new" onClick={initGame}>New Game</button>
              )}
            </div>
            
            {message && (
              <div style={{
                position: 'absolute',
                top: '10%',
                left: '50%',
                transform: 'translateX(-50%)',
                fontSize: '1.5rem',
                background: 'rgba(0,0,0,0.7)',
                padding: '10px 20px',
                borderRadius: '8px'
              }}>
                {message}
              </div>
            )}
          </div>
        );
      };
      
      ReactDOM.render(<PokerGameComponent />, document.getElementById('root'));
    </script>
    <!-- Particles.js green configuration -->
    <script>
      particlesJS("particles-js", {
        "particles": {
          "number": { "value": 80, "density": { "enable": true, "value_area": 800 } },
          "color": { "value": "#00ff00" },
          "shape": { "type": "circle", "stroke": { "width": 0, "color": "#000" } },
          "opacity": { "value": 0.5, "random": false },
          "size": { "value": 3, "random": true },
          "line_linked": { "enable": true, "distance": 150, "color": "#00ff00", "opacity": 0.4, "width": 1 },
          "move": { "enable": true, "speed": 2, "direction": "none", "random": false, "straight": false, "out_mode": "out" }
        },
        "interactivity": {
          "detect_on": "canvas",
          "events": {
            "onhover": { "enable": true, "mode": "repulse" },
            "onclick": { "enable": true, "mode": "push" }
          },
          "modes": {
            "repulse": { "distance": 100, "duration": 0.4 },
            "push": { "particles_nb": 4 }
          }
        },
        "retina_detect": true
      });
    </script>
  </body>
</html>
