<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adventure Platformer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #222;
            overflow: hidden;
        }
        canvas {
            display: block;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <script>
        // Game Constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 500;
        const GROUND_LEVEL = CANVAS_HEIGHT - 50;
        const GRAVITY = 0.8;
        const PLAYER_SPEED = 5;
        const JUMP_FORCE = 15;
        const BLOCK_SIZE = 40;
        
        // Game Variables
        let player;
        let platforms = [];
        let enemies = [];
        let collectibles = [];
        let particles = [];
        let clouds = [];
        let currentLevel = 0;
        let score = 0;
        let gameState = "START"; // START, PLAYING, GAME_OVER
        let cameraX = 0;
        let bgLayers = [];
        
        // Player sprites
        let playerSprites = {
            idle: [],
            run: [],
            jump: [],
            fall: []
        };
        
        // Enemy sprites
        let enemySprites = {
            walk: [],
            squished: null
        };
        
        // Game sprites and images
        let coinSprite;
        let blockSprites = {};
        let cloudImage;
        let bgImages = [];
        let flagImage;
        let heartImage;
        
        // Game sound effects
        let jumpSound;
        let coinSound;
        let enemySquishSound;
        let gameOverSound;
        let victorySound;
        let themeSong;
        
        // Level definitions
        const levels = [
            {
                platforms: [
                    { x: 0, y: GROUND_LEVEL, width: 800, height: 50, type: "ground" },
                    { x: 250, y: 350, width: 200, height: 40, type: "platform" },
                    { x: 500, y: 280, width: 120, height: 40, type: "platform" },
                    { x: 700, y: 200, width: 150, height: 40, type: "platform" },
                    { x: 900, y: 300, width: 250, height: 40, type: "platform" },
                    { x: 1200, y: 350, width: 100, height: 40, type: "platform" },
                    { x: 1350, y: 270, width: 120, height: 40, type: "platform" },
                    { x: 1520, y: 200, width: 100, height: 40, type: "platform" },
                    { x: 1650, y: 300, width: 250, height: 40, type: "platform" },
                    { x: 1950, y: GROUND_LEVEL, width: 500, height: 50, type: "ground" }
                ],
                enemies: [
                    { x: 400, y: 310, type: "walker", direction: -1, range: 150 },
                    { x: 900, y: 260, type: "walker", direction: 1, range: 200 },
                    { x: 1700, y: 260, type: "walker", direction: -1, range: 150 }
                ],
                collectibles: [
                    { x: 300, y: 300, type: "coin" },
                    { x: 350, y: 300, type: "coin" },
                    { x: 550, y: 230, type: "coin" },
                    { x: 750, y: 150, type: "coin" },
                    { x: 950, y: 250, type: "coin" },
                    { x: 1000, y: 250, type: "coin" },
                    { x: 1400, y: 220, type: "coin" },
                    { x: 1550, y: 150, type: "coin" },
                    { x: 1700, y: 250, type: "coin" },
                    { x: 1750, y: 250, type: "coin" }
                ],
                end: { x: 2200, y: GROUND_LEVEL - 200, type: "flag" },
                background: 0
            },
            {
                platforms: [
                    { x: 0, y: GROUND_LEVEL, width: 400, height: 50, type: "ground" },
                    { x: 450, y: GROUND_LEVEL, width: 200, height: 50, type: "ground" },
                    { x: 700, y: GROUND_LEVEL, width: 300, height: 50, type: "ground" },
                    { x: 1050, y: GROUND_LEVEL, width: 200, height: 50, type: "ground" },
                    { x: 1300, y: GROUND_LEVEL, width: 600, height: 50, type: "ground" },
                    { x: 250, y: 350, width: 100, height: 40, type: "platform" },
                    { x: 400, y: 280, width: 80, height: 40, type: "platform" },
                    { x: 530, y: 350, width: 80, height: 40, type: "platform" },
                    { x: 900, y: 320, width: 120, height: 40, type: "platform" },
                    { x: 1050, y: 250, width: 100, height: 40, type: "platform" },
                    { x: 1200, y: 180, width: 80, height: 40, type: "platform" },
                    { x: 1350, y: 250, width: 100, height: 40, type: "platform" },
                    { x: 1550, y: 300, width: 150, height: 40, type: "platform" }
                ],
                enemies: [
                    { x: 300, y: 310, type: "walker", direction: -1, range: 100 },
                    { x: 550, y: 310, type: "walker", direction: 1, range: 80 },
                    { x: 800, y: GROUND_LEVEL - 40, type: "walker", direction: 1, range: 200 },
                    { x: 900, y: 280, type: "walker", direction: -1, range: 100 },
                    { x: 1400, y: GROUND_LEVEL - 40, type: "walker", direction: -1, range: 250 },
                    { x: 1600, y: 260, type: "walker", direction: 1, range: 120 }
                ],
                collectibles: [
                    { x: 260, y: 300, type: "coin" },
                    { x: 300, y: 300, type: "coin" },
                    { x: 410, y: 230, type: "coin" },
                    { x: 450, y: 230, type: "coin" },
                    { x: 540, y: 300, type: "coin" },
                    { x: 580, y: 300, type: "coin" },
                    { x: 900, y: 270, type: "coin" },
                    { x: 950, y: 270, type: "coin" },
                    { x: 1050, y: 200, type: "coin" },
                    { x: 1100, y: 200, type: "coin" },
                    { x: 1200, y: 130, type: "coin" },
                    { x: 1350, y: 200, type: "coin" },
                    { x: 1400, y: 200, type: "coin" },
                    { x: 1570, y: 250, type: "coin" },
                    { x: 1620, y: 250, type: "coin" }
                ],
                end: { x: 1800, y: GROUND_LEVEL - 200, type: "flag" },
                background: 1
            }
        ];
        
        // Preload game assets
        function preload() {
            // Load player sprites
            for (let i = 1; i <= 4; i++) {
                playerSprites.idle.push(loadImage(`https://raw.githubusercontent.com/photonstorm/phaser-examples/master/examples/assets/sprites/walking_dude_idle_0${i}.png`));
                playerSprites.run.push(loadImage(`https://raw.githubusercontent.com/photonstorm/phaser-examples/master/examples/assets/sprites/running_bot_0${i}.png`));
            }
            playerSprites.jump.push(loadImage('https://raw.githubusercontent.com/photonstorm/phaser-examples/master/examples/assets/sprites/phaser-dude.png'));
            playerSprites.fall.push(loadImage('https://raw.githubusercontent.com/photonstorm/phaser-examples/master/examples/assets/sprites/phaser-dude.png'));
            
            // Load enemy sprites
            enemySprites.walk.push(loadImage('https://raw.githubusercontent.com/photonstorm/phaser-examples/master/examples/assets/sprites/slime.png'));
            enemySprites.squished = loadImage('https://raw.githubusercontent.com/photonstorm/phaser-examples/master/examples/assets/sprites/slimeeyes.png');
            
            // Load game sprites
            coinSprite = loadImage('https://raw.githubusercontent.com/photonstorm/phaser-examples/master/examples/assets/sprites/coin.png');
            blockSprites.platform = loadImage('https://raw.githubusercontent.com/photonstorm/phaser-examples/master/examples/assets/sprites/platform.png');
            blockSprites.ground = loadImage('https://raw.githubusercontent.com/photonstorm/phaser-examples/master/examples/assets/sprites/platform.png');
            cloudImage = loadImage('https://raw.githubusercontent.com/photonstorm/phaser-examples/master/examples/assets/sprites/cloud.png');
            flagImage = loadImage('https://raw.githubusercontent.com/photonstorm/phaser-examples/master/examples/assets/sprites/flag.png');
            heartImage = loadImage('https://raw.githubusercontent.com/photonstorm/phaser-examples/master/examples/assets/sprites/heart.png');
            
            // Load background images
            bgImages.push(loadImage('https://raw.githubusercontent.com/photonstorm/phaser-examples/master/examples/assets/skies/sky1.png'));
            bgImages.push(loadImage('https://raw.githubusercontent.com/photonstorm/phaser-examples/master/examples/assets/skies/sky2.png'));
            
            // Create parallax background layers
            for (let i = 0; i < 3; i++) {
                bgLayers.push({
                    img: loadImage(`https://raw.githubusercontent.com/photonstorm/phaser-examples/master/examples/assets/sprites/mountains-${i + 1}.png`),
                    scrollFactor: 0.2 * (i + 1)
                });
            }
            
            // Load sounds (commented out to avoid issues with sound loading in some browsers)
            /*
            soundFormats('mp3', 'ogg');
            jumpSound = loadSound('assets/sounds/jump.mp3');
            coinSound = loadSound('assets/sounds/coin.mp3');
            enemySquishSound = loadSound('assets/sounds/squish.mp3');
            gameOverSound = loadSound('assets/sounds/game_over.mp3');
            victorySound = loadSound('assets/sounds/victory.mp3');
            themeSong = loadSound('assets/sounds/theme.mp3');
            */
        }
        
        // Setup function
        function setup() {
            createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
            imageMode(CENTER);
            resetGame();
            
            // Create clouds
            for (let i = 0; i < 10; i++) {
                clouds.push({
                    x: random(-500, 2000),
                    y: random(50, 150),
                    speed: random(0.2, 0.5),
                    scale: random(0.5, 1.5),
                    alpha: random(150, 255)
                });
            }
        }
        
        // Reset game state
        function resetGame() {
            player = {
                x: 100,
                y: 300,
                width: 30,
                height: 50,
                velocityX: 0,
                velocityY: 0,
                isJumping: false,
                direction: 1, // 1 for right, -1 for left
                animation: "idle",
                frameCount: 0,
                currentFrame: 0,
                lives: 3,
                invulnerable: false,
                invulnerableTimer: 0
            };
            
            score = 0;
            loadLevel(currentLevel);
            gameState = "PLAYING";
            cameraX = 0;
            
            // Play theme song (commented out)
            // if (themeSong) themeSong.loop();
        }
        
        // Load a specific level
        function loadLevel(levelIndex) {
            if (levelIndex >= levels.length) {
                gameState = "VICTORY";
                return;
            }
            
            const level = levels[levelIndex];
            platforms = level.platforms;
            enemies = JSON.parse(JSON.stringify(level.enemies)); // Deep copy
            collectibles = JSON.parse(JSON.stringify(level.collectibles)); // Deep copy
            endFlag = level.end;
            currentBackground = level.background;
        }
        
        // Main draw function
        function draw() {
            if (gameState === "START") {
                drawStartScreen();
            } else if (gameState === "PLAYING") {
                updateGame();
                drawGame();
            } else if (gameState === "GAME_OVER") {
                drawGameOverScreen();
            } else if (gameState === "VICTORY") {
                drawVictoryScreen();
            } else if (gameState === "LEVEL_COMPLETE") {
                drawLevelCompleteScreen();
            }
        }
        
        // Update game state
        function updateGame() {
            updatePlayer();
            updateEnemies();
            updateCollectibles();
            updateParticles();
            updateClouds();
            checkLevelComplete();
            
            // Camera follows player
            cameraX = -player.x + width / 3;
            cameraX = constrain(cameraX, -2500, 0); // Limit camera position
            
            // Check if player fell off the screen
            if (player.y > height + 100) {
                playerDie();
            }
            
            // Update invulnerability timer
            if (player.invulnerable) {
                player.invulnerableTimer--;
                if (player.invulnerableTimer <= 0) {
                    player.invulnerable = false;
                }
            }
        }
        
        // Draw game elements
        function drawGame() {
            // Draw background
            background(100, 180, 255);
            
            // Draw background image
            image(bgImages[currentBackground], width/2, height/2, width, height);
            
            push();
            translate(cameraX, 0);
            
            // Draw parallax background layers
            for (let layer of bgLayers) {
                image(layer.img, width/2 - cameraX * layer.scrollFactor, height - layer.img.height/2, layer.img.width, layer.img.height);
            }
            
            // Draw clouds
            for (let cloud of clouds) {
                push();
                tint(255, cloud.alpha);
                image(cloudImage, cloud.x, cloud.y, cloudImage.width * cloud.scale, cloudImage.height * cloud.scale);
                pop();
            }
            
            // Draw platforms
            for (let platform of platforms) {
                // Repeat the platform image to fill the width
                const img = blockSprites[platform.type] || blockSprites.platform;
                const tileSize = platform.height;
                for (let x = platform.x; x < platform.x + platform.width; x += tileSize) {
                    image(img, x + tileSize/2, platform.y + tileSize/2, tileSize, tileSize);
                }
            }
            
            // Draw collectibles
            for (let collectible of collectibles) {
                if (collectible.type === "coin") {
                    image(coinSprite, collectible.x, collectible.y, 25, 25);
                }
            }
            
            // Draw end flag
            if (endFlag) {
                image(flagImage, endFlag.x, endFlag.y, 50, 100);
            }
            
            // Draw enemies
            for (let enemy of enemies) {
                if (!enemy.squished) {
                    push();
                    scale(enemy.direction, 1); // Flip based on direction
                    if (enemy.type === "walker") {
                        image(enemySprites.walk[0], enemy.direction * enemy.x, enemy.y, 40, 30);
                    }
                    pop();
                } else {
                    image(enemySprites.squished, enemy.x, enemy.y + 10, 40, 20);
                }
            }
            
            // Draw particles
            for (let particle of particles) {
                noStroke();
                fill(particle.color[0], particle.color[1], particle.color[2], particle.alpha);
                ellipse(particle.x, particle.y, particle.size, particle.size);
            }
            
            // Draw player
            push();
            scale(player.direction, 1); // Flip based on direction
            
            if (player.invulnerable && frameCount % 6 < 3) {
                // Blink when invulnerable
                tint(255, 127);
            }
            
            const currentAnim = playerSprites[player.animation];
            if (currentAnim && currentAnim.length > 0) {
                image(currentAnim[player.currentFrame], player.direction * player.x, player.y, player.width * 1.5, player.height * 1.5);
            }
            pop();
            
            pop(); // End camera translation
            
            // Draw UI elements (not affected by camera)
            drawUI();
        }
        
        // Update player state
        function updatePlayer() {
            // Handle horizontal movement
            if (keyIsDown(LEFT_ARROW) || keyIsDown(65)) { // Left arrow or A
                player.velocityX = -PLAYER_SPEED;
                player.direction = -1;
                if (!player.isJumping) {
                    player.animation = "run";
                }
            } else if (keyIsDown(RIGHT_ARROW) || keyIsDown(68)) { // Right arrow or D
                player.velocityX = PLAYER_SPEED;
                player.direction = 1;
                if (!player.isJumping) {
                    player.animation = "run";
                }
            } else {
                player.velocityX = 0;
                if (!player.isJumping) {
                    player.animation = "idle";
                }
            }
            
            // Apply gravity
            player.velocityY += GRAVITY;
            
            // Update position
            player.x += player.velocityX;
            player.y += player.velocityY;
            
            // Check for platform collisions
            let onGround = false;
            for (let platform of platforms) {
                if (collideRectRect(
                    player.x - player.width/2, player.y - player.height/2, player.width, player.height,
                    platform.x, platform.y, platform.width, platform.height
                )) {
                    // Check if landing on top of platform
                    if (player.velocityY > 0 && player.y - player.height/2 < platform.y) {
                        player.y = platform.y - player.height/2;
                        player.velocityY = 0;
                        onGround = true;
                    }
                    // Check if hitting side of platform
                    else if (player.velocityX > 0 && player.x + player.width/2 > platform.x && player.x < platform.x) {
                        player.x = platform.x - player.width/2;
                    } 
                    else if (player.velocityX < 0 && player.x - player.width/2 < platform.x + platform.width && player.x > platform.x + platform.width) {
                        player.x = platform.x + platform.width + player.width/2;
                    }
                    // Check if hitting bottom of platform
                    else if (player.velocityY < 0) {
                        player.y = platform.y + platform.height + player.height/2;
                        player.velocityY = 1;
                    }
                }
            }
            
            // Update jumping state
            if (onGround) {
                player.isJumping = false;
            } else {
                player.isJumping = true;
                player.animation = player.velocityY < 0 ? "jump" : "fall";
            }
            
            // Check for enemy collisions
            for (let enemy of enemies) {
                if (!enemy.squished && collideRectRect(
                    player.x - player.width/2, player.y - player.height/2, player.width, player.height,
                    enemy.x - 20, enemy.y - 15, 40, 30
                )) {
                    // If player is falling onto enemy, squish enemy
                    if (player.velocityY > 0 && player.y - player.height/2 < enemy.y - 10) {
                        enemy.squished = true;
                        player.velocityY = -JUMP_FORCE * 0.7; // Bounce off enemy
                        score += 100;
                        createParticles(enemy.x, enemy.y, 10, [0, 255, 0]);
                        // Play squish sound (commented out)
                        // if (enemySquishSound) enemySquishSound.play();
                    } 
                    // Otherwise player gets hurt
                    else if (!player.invulnerable) {
                        playerHit();
                    }
                }
            }
            
            // Check for collectible collisions
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                if (dist(player.x, player.y, collectible.x, collectible.y) < 30) {
                    if (collectible.type === "coin") {
                        score += 50;
                        collectibles.splice(i, 1);
                        createParticles(collectible.x, collectible.y, 5, [255, 215, 0]);
                        // Play coin sound (commented out)
                        // if (coinSound) coinSound.play();
                    }
                }
            }
            
            // Check for level completion
            if (endFlag && dist(player.x, player.y, endFlag.x, endFlag.y) < 50) {
                completeLevel();
            }
            
            // Animate player
            player.frameCount++;
            if (player.frameCount > 5) {
                player.frameCount = 0;
                player.currentFrame = (player.currentFrame + 1) % playerSprites[player.animation].length;
            }
        }
        
        // Update enemies
        function updateEnemies() {
            for (let enemy of enemies) {
                if (!enemy.squished) {
                    // Move enemy
                    enemy.x += enemy.direction * 2;
                    
                    // Check if enemy hit its movement boundaries
                    if (enemy.initialX === undefined) {
                        enemy.initialX = enemy.x;
                    }
                    
                    if (enemy.x < enemy.initialX - enemy.range || enemy.x > enemy.initialX + enemy.range) {
                        enemy.direction *= -1;
                    }
                    
                    // Check if enemy is on platform
                    let onPlatform = false;
                    for (let platform of platforms) {
                        if (enemy.x >= platform.x && enemy.x <= platform.x + platform.width &&
                            enemy.y >= platform.y - 15 && enemy.y <= platform.y + 5) {
                            onPlatform = true;
                            break;
                        }
                    }
                    
                    // Change direction if not on platform
                    if (!onPlatform) {
                        enemy.direction *= -1;
                        enemy.x += enemy.direction * 10; // Move back onto platform
                    }
                } else {
                    // Squished enemy disappears after a while
                    if (enemy.squishedTimer === undefined) {
                        enemy.squishedTimer = 30;
                    }
                    enemy.squishedTimer--;
                    if (enemy.squishedTimer <= 0) {
                        enemy.remove = true;
                    }
                }
            }
            
            // Remove squished enemies
            enemies = enemies.filter(enemy => !enemy.remove);
        }
        
        // Update collectibles (simple animation)
        function updateCollectibles() {
            for (let collectible of collectibles) {
                if (collectible.type === "coin") {
                    // Make coins float up and down
                    if (collectible.floatOffset === undefined) {
                        collectible.floatOffset = random(0, TWO_PI);
                        collectible.originalY = collectible.y;
                    }
                    collectible.y = collectible.originalY + sin(frameCount * 0.05 + collectible.floatOffset) * 5;
                }
            }
        }
        
        // Update particles
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.velocityX;
                particle.y += particle.velocityY;
                particle.velocityY += 0.2; // Gravity
                particle.alpha -= 5;
                particle.size *= 0.95;
                
                if (particle.alpha <= 0 || particle.size < 0.5) {
                    particles.splice(i, 1);
                }
            }
        }
        
        // Update clouds
        function updateClouds() {
            for (let cloud of clouds) {
                cloud.x += cloud.speed;
                if (cloud.x > 2500) {
                    cloud.x = -500;
                    cloud.y = random(50, 150);
                }
            }
        }
        
        // Create particles
        function createParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    velocityX: random(-3, 3),
                    velocityY: random(-5, 0),
                    size: random(5, 10),
                    color: color,
                    alpha: 255
                });
            }
        }
        
        // Player jump function
        function playerJump() {
            if (!player.isJumping) {
                player.velocityY = -JUMP_FORCE;
                player.isJumping = true;
                player.animation = "jump";
                
                // Create jump dust effect
                createParticles(player.x, player.y + player.height/2, 5, [200, 200, 200]);
                
                // Play jump sound (commented out)
                // if (jumpSound) jumpSound.play();
            }
        }
        
        // Player hit by enemy
        function playerHit() {
            player.lives--;
            player.invulnerable = true;
            player.invulnerableTimer = 60; // 1 second of invulnerability
            
            if (player.lives <= 0) {
                gameOver();
            } else {
                // Knockback
                player.velocityY = -10;
                player.velocityX = player.direction * -8;
            }
        }
        
        // Player dies
        function playerDie() {
            player.lives = 0;
            gameOver();
        }
        
        // Game over
        function gameOver() {
            gameState = "GAME_OVER";
            // Stop music (commented out)
            // if (themeSong) themeSong.stop();
            // Play game over sound (commented out)
            // if (gameOverSound) gameOverSound.play();
        }
        
        // Complete level
        function completeLevel() {
            gameState = "LEVEL_COMPLETE";
            // Play victory sound (commented out)
            // if (victorySound) victorySound.play();
        }
        
        // Check if level is complete
        function checkLevelComplete() {
            if (endFlag && dist(player.x, player.y, endFlag.x, endFlag.y) < 50) {
                completeLevel();
            }
        }
        
        // Draw UI
        function drawUI() {
            // Score display
            fill(0, 0, 0, 150);
            rect(10, 10, 150, 40, 5);
            fill(255);
            textSize(20);
            textAlign(LEFT, CENTER);
            text(`Score: ${score}`, 20, 30);
            
            // Lives display
            for (let i = 0; i < player.lives; i++) {
                image(heartImage, width - 30 - i * 30, 30, 25, 25);
            }
        }
        
        // Draw start screen
        function drawStartScreen() {
            background(0, 0, 50);
            image(bgImages[0], width/2, height/2, width, height);
            
            // Title
            fill(255);
            textSize(50);
            textAlign(CENTER, CENTER);
            text("ADVENTURE PLATFORMER", width/2, height/3);
            
            // Instructions
            textSize(20);
            text("Arrow keys or WASD to move, Spacebar to jump", width/2, height/2);
            
            // Start prompt
            textSize(25);
            fill(255, 255, 0);
            text("Press ENTER to start", width/2, height * 2/3);
            
            // Animate start prompt
            if (frameCount % 60 < 30) {
                text("Press ENTER to start", width/2, height * 2/3);
            }
        }
        
        // Draw game over screen
        function drawGameOverScreen() {
            fill(0, 0, 0, 200);
            rect(0, 0, width, height);
            
            fill(255, 50, 50);
            textSize(50);
            textAlign(CENTER, CENTER);
            text("GAME OVER", width/2, height/3);
            
            fill(255);
            textSize(25);
            text(`Final Score: ${score}`, width/2, height/2);
            
            textSize(20);
            fill(255, 255, 0);
            if (frameCount % 60 < 30) {
                text("Press R to restart", width/2, height * 2/3);
            }
        }
        
        // Draw victory screen
        function drawVictoryScreen() {
            fill(0, 0, 0, 200);
            rect(0, 0, width, height);
            
            fill(50, 255, 50);
            textSize(50);
            textAlign(CENTER, CENTER);
            text("VICTORY!", width/2, height/3);
            
            fill(255);
            textSize(25);
            text(`Final Score: ${score}`, width/2, height/2);
            
            textSize(20);
            fill(255, 255, 0);
            if (frameCount % 60 < 30) {
                text("Press R to play again", width/2, height * 2/3);
            }
        }
        
        // Draw level complete screen
        function drawLevelCompleteScreen() {
            fill(0, 0, 0, 200);
            rect(0, 0, width, height);
            
            fill(50, 200, 255);
            textSize(40);
            textAlign(CENTER, CENTER);
            text(`LEVEL ${currentLevel + 1} COMPLETE!`, width/2, height/3);
            
            fill(255);
            textSize(25);
            text(`Score: ${score}`, width/2, height/2);
            
            textSize(20);
            fill(255, 255, 0);
            if (frameCount % 60 < 30) {
                text("Press ENTER to continue", width/2, height * 2/3);
            }
        }
        
        // Key pressed event handler
        function keyPressed() {
            if (keyCode === 32) { // Space bar
                if (gameState === "PLAYING") {
                    playerJump();
                }
            }
            
            if (keyCode === ENTER) {
                if (gameState === "START") {
                    resetGame();
                } else if (gameState === "LEVEL_COMPLETE") {
                    currentLevel++;
                    loadLevel(currentLevel);
                    gameState = "PLAYING";
                }
            }
            
            if (keyCode === 82) { // R key
                if (gameState === "GAME_OVER" || gameState === "VICTORY") {
                    currentLevel = 0;
                    resetGame();
                }
            }
        }
        
        // Helper function to check rectangle collision
        function collideRectRect(x1, y1, w1, h1, x2, y2, w2, h2) {
            return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
        }
    </script>
</body>
</html>
