<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GBA Emulator - 3D TV</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
  <style>
    :root {
      --bg-color: #111;
      --text-color: #eee;
      --accent: #ff3e3e;
      --panel-bg: #222;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
    }
    
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    header {
      padding: 15px 0;
      text-align: center;
    }
    
    h1 {
      font-size: 24px;
      margin-bottom: 5px;
      background: linear-gradient(90deg, #ff3e3e, #ff9e3e);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }
    
    #tv-container {
      width: 100%;
      height: 60vh;
      position: relative;
      overflow: hidden;
      margin: 0 auto;
    }
    
    #controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    .panel {
      background-color: var(--panel-bg);
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .panel h2 {
      font-size: 16px;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid #333;
    }
    
    .btn {
      background-color: #333;
      color: var(--text-color);
      border: none;
      padding: 8px 12px;
      margin: 5px 0;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
      width: 100%;
      text-align: left;
    }
    
    .btn:hover {
      background-color: #444;
    }
    
    .btn.primary {
      background-color: var(--accent);
    }
    
    .btn.primary:hover {
      background-color: #ff5252;
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .upload-area {
      border: 2px dashed #444;
      border-radius: 8px;
      padding: 15px;
      text-align: center;
      margin-bottom: 15px;
      transition: all 0.2s;
      cursor: pointer;
    }
    
    .upload-area:hover {
      border-color: var(--accent);
      background-color: rgba(255, 62, 62, 0.05);
    }
    
    #rom-input {
      display: none;
    }
    
    .ai-log {
      height: 150px;
      overflow-y: auto;
      margin-top: 10px;
      background-color: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      padding: 8px;
      font-family: monospace;
      font-size: 12px;
      color: #0f0;
    }
    
    .ai-log p {
      margin: 2px 0;
    }
    
    .controls-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 5px;
      margin-top: 10px;
    }
    
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 1;
      transition: opacity 0.3s;
    }
    
    .modal-content {
      background-color: var(--panel-bg);
      border-radius: 8px;
      padding: 20px;
      max-width: 500px;
      width: 90%;
      position: relative;
    }
    
    .close-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: var(--text-color);
      font-size: 20px;
      cursor: pointer;
    }
    
    .status-badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 12px;
      margin-left: 5px;
    }
    
    .status-active {
      background-color: #00b894;
    }
    
    .status-inactive {
      background-color: #636e72;
    }
    
    .status-training {
      background-color: #fdcb6e;
      color: #222;
    }
    
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s linear infinite;
      margin-left: 10px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>GameBoy Advance Emulator</h1>
      <p>Upload a ROM and play, or let the AI take control</p>
    </header>
    
    <div id="tv-container"></div>
    
    <div id="controls">
      <div class="panel">
        <h2>Game</h2>
        <div class="upload-area" id="upload-area">
          <p>Drop your ROM file here or click to browse</p>
          <p id="rom-name" style="display: none;"></p>
          <input type="file" id="rom-input" accept=".gba">
        </div>
        
        <button id="start-btn" class="btn primary" disabled>Start Game</button>
        <button id="pause-btn" class="btn" disabled>Pause</button>
        <button id="reset-btn" class="btn" disabled>Reset</button>
        <button id="save-btn" class="btn" disabled>Save State</button>
        <button id="load-btn" class="btn" disabled>Load State</button>
      </div>
      
      <div class="panel">
        <h2>AI Player <span id="ai-status" class="status-badge status-inactive">Inactive</span></h2>
        <button id="ai-play-btn" class="btn primary" disabled>Let AI Play</button>
        <button id="ai-stop-btn" class="btn" disabled>Take Control</button>
        <button id="ai-train-btn" class="btn" disabled>Train AI</button>
        
        <div class="ai-log" id="ai-log"></div>
      </div>
      
      <div class="panel">
        <h2>Controls</h2>
        <p>Press keyboard or use buttons:</p>
        <div class="controls-grid">
          <button class="btn" data-key="up">↑ (W)</button>
          <button class="btn" data-key="b">B (Z)</button>
          <button class="btn" data-key="start">START (Enter)</button>
          <button class="btn" data-key="left">← (A)</button>
          <button class="btn" data-key="a">A (X)</button>
          <button class="btn" data-key="select">SELECT (Space)</button>
          <button class="btn" data-key="down">↓ (S)</button>
          <button class="btn" data-key="r">R (E)</button>
          <button class="btn" data-key="right">→ (D)</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Tutorial Modal -->
  <div class="modal" id="tutorial-modal">
    <div class="modal-content">
      <button class="close-btn" id="close-tutorial">&times;</button>
      <h2>Welcome to GBA Emulator</h2>
      <p>This emulator allows you to play Game Boy Advance games and watch an AI learn to play them.</p>
      <h3>Getting Started:</h3>
      <ol>
        <li>Upload a GBA ROM file (.gba)</li>
        <li>Click "Start Game" to begin</li>
        <li>Use keyboard controls or on-screen buttons</li>
        <li>Try "Let AI Play" to watch the AI agent play</li>
      </ol>
      <p>The AI is specially designed to handle Pokemon games like Fire Red!</p>
      <button class="btn primary" id="start-tutorial">Got it!</button>
    </div>
  </div>

  <script>
    // Main application code
    document.addEventListener('DOMContentLoaded', function() {
      // DOM Elements
      const romInput = document.getElementById('rom-input');
      const uploadArea = document.getElementById('upload-area');
      const romName = document.getElementById('rom-name');
      const startBtn = document.getElementById('start-btn');
      const pauseBtn = document.getElementById('pause-btn');
      const resetBtn = document.getElementById('reset-btn');
      const saveBtn = document.getElementById('save-btn');
      const loadBtn = document.getElementById('load-btn');
      const aiPlayBtn = document.getElementById('ai-play-btn');
      const aiStopBtn = document.getElementById('ai-stop-btn');
      const aiTrainBtn = document.getElementById('ai-train-btn');
      const aiStatus = document.getElementById('ai-status');
      const aiLog = document.getElementById('ai-log');
      const tutorialModal = document.getElementById('tutorial-modal');
      const closeTutorial = document.getElementById('close-tutorial');
      const startTutorial = document.getElementById('start-tutorial');
      
      // Global variables
      let romData = null;
      let emulator = null;
      let isGameRunning = false;
      let isAIPlaying = false;
      let aiAgent = null;
      let gameLoop = null;
      let tvRenderer = null;
      let currentKeys = new Set();
      
      // 3D TV Setup
      function initTV() {
        const tvContainer = document.getElementById('tv-container');
        
        // Create a scene
        const scene = new THREE.Scene();
        
        // Create a camera
        const camera = new THREE.PerspectiveCamera(75, tvContainer.clientWidth / tvContainer.clientHeight, 0.1, 1000);
        camera.position.z = 5;
        
        // Create a renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(tvContainer.clientWidth, tvContainer.clientHeight);
        renderer.setClearColor(0x000000, 1);
        tvContainer.appendChild(renderer.domElement);
        
        // TV model
        const tvWidth = 6;
        const tvHeight = 3.6;
        const tvDepth = 0.5;
        
        // TV body
        const tvGeometry = new THREE.BoxGeometry(tvWidth, tvHeight, tvDepth);
        const tvMaterial = new THREE.MeshPhongMaterial({ 
          color: 0x222222, 
          specular: 0x444444,
          shininess: 30
        });
        const tv = new THREE.Mesh(tvGeometry, tvMaterial);
        scene.add(tv);
        
        // TV screen
        const screenWidth = tvWidth * 0.9;
        const screenHeight = tvHeight * 0.9;
        const screenGeometry = new THREE.PlaneGeometry(screenWidth, screenHeight);
        
        // Create dynamic texture for screen
        const screenCanvas = document.createElement('canvas');
        screenCanvas.width = 240;
        screenCanvas.height = 160;
        const screenContext = screenCanvas.getContext('2d');
        screenContext.fillStyle = 'black';
        screenContext.fillRect(0, 0, screenCanvas.width, screenCanvas.height);
        
        const screenTexture = new THREE.CanvasTexture(screenCanvas);
        screenTexture.minFilter = THREE.NearestFilter;
        screenTexture.magFilter = THREE.NearestFilter;
        
        const screenMaterial = new THREE.MeshBasicMaterial({ 
          map: screenTexture,
          side: THREE.FrontSide
        });
        
        const screen = new THREE.Mesh(screenGeometry, screenMaterial);
        screen.position.z = tvDepth / 2 + 0.01; // Slightly in front of the TV
        scene.add(screen);
        
        // TV stand
        const standGeometry = new THREE.BoxGeometry(tvWidth / 2, 0.3, tvDepth * 1.5);
        const standMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
        const stand = new THREE.Mesh(standGeometry, standMaterial);
        stand.position.y = -tvHeight / 2 - 0.15;
        scene.add(stand);
        
        // Base stand
        const baseGeometry = new THREE.BoxGeometry(tvWidth / 1.5, 0.1, tvDepth * 2);
        const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = -tvHeight / 2 - 0.3;
        scene.add(base);
        
        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        // Add directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 5);
        scene.add(directionalLight);
        
        // Set up animation loop
        function animate() {
          requestAnimationFrame(animate);
          
          // Gentle floating effect
          tv.rotation.y = Math.sin(Date.now() * 0.0005) * 0.05;
          tv.position.y = Math.sin(Date.now() * 0.001) * 0.05;
          screen.rotation.y = tv.rotation.y;
          screen.position.y = tv.position.y;
          stand.rotation.y = tv.rotation.y;
          stand.position.y = -tvHeight / 2 - 0.15 + tv.position.y;
          base.rotation.y = tv.rotation.y;
          
          renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
          camera.aspect = tvContainer.clientWidth / tvContainer.clientHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(tvContainer.clientWidth, tvContainer.clientHeight);
        });
        
        // Start animation
        animate();
        
        // Return objects needed for updating the screen
        return {
          canvas: screenCanvas,
          context: screenContext,
          texture: screenTexture
        };
      }
      
      // Initialize TV
      tvRenderer = initTV();
      
      // Mock GBA Emulator for demonstration
      class GBAEmulator {
        constructor(romData) {
          this.romData = romData;
          this.running = false;
          this.frameBuffer = new Uint8Array(240 * 160 * 4); // RGBA buffer
          this.saveState = null;
          this.currentKeys = new Set();
          this.frameCount = 0;
          
          // For demo, fill with static initially
          this.fillStatic();
          
          // Extract ROM info
          this.romInfo = {
            title: this.extractTitle(romData.name || "Unknown Game"),
            size: romData.byteLength || 0
          };
        }
        
        extractTitle(filename) {
          return filename.replace(/\.gba$/i, "");
        }
        
        fillStatic() {
          for (let i = 0; i < this.frameBuffer.length; i += 4) {
            this.frameBuffer[i] = Math.floor(Math.random() * 100);     // R
            this.frameBuffer[i + 1] = Math.floor(Math.random() * 100); // G
            this.frameBuffer[i + 2] = Math.floor(Math.random() * 100); // B
            this.frameBuffer[i + 3] = 255;                             // A
          }
        }
        
        // Initialize Pokemon FireRed specific screen
        initPokemonScreen() {
          // Clear frame buffer
          for (let i = 0; i < this.frameBuffer.length; i += 4) {
            this.frameBuffer[i] = 255;     // R
            this.frameBuffer[i + 1] = 255; // G
            this.frameBuffer[i + 2] = 255; // B
            this.frameBuffer[i + 3] = 255; // A
          }
          
          // Mock Pokemon FireRed title screen using basic colors
          // Top portion - red
          for (let y = 0; y < 60; y++) {
            for (let x = 0; x < 240; x++) {
              const idx = (y * 240 + x) * 4;
              this.frameBuffer[idx] = 255;   // R
              this.frameBuffer[idx + 1] = 50; // G
              this.frameBuffer[idx + 2] = 50; // B
            }
          }
          
          // Middle portion - white
          for (let y = 60; y < 100; y++) {
            for (let x = 0; x < 240; x++) {
              const idx = (y * 240 + x) * 4;
              this.frameBuffer[idx] = 255;     // R
              this.frameBuffer[idx + 1] = 255; // G
              this.frameBuffer[idx + 2] = 255; // B
            }
          }
          
          // Bottom portion - darker red
          for (let y = 100; y < 160; y++) {
            for (let x = 0; x < 240; x++) {
              const idx = (y * 240 + x) * 4;
              this.frameBuffer[idx] = 200;   // R
              this.frameBuffer[idx + 1] = 30; // G
              this.frameBuffer[idx + 2] = 30; // B
            }
          }
        }
        
        start() {
          this.running = true;
          
          // Check if it's Pokemon FireRed
          if (this.romInfo.title.toLowerCase().includes("fire") && 
              this.romInfo.title.toLowerCase().includes("red")) {
            this.initPokemonScreen();
          }
          
          this.renderLoop();
        }
        
        pause() {
          this.running = false;
        }
        
        reset() {
          this.running = false;
          this.fillStatic();
        }
        
        renderLoop() {
          if (!this.running) return;
          
          // Update frame
          this.frameCount++;
          this.updateFrame();
          
          // Request next frame
          requestAnimationFrame(() => this.renderLoop());
        }
        
        updateFrame() {
          // In a real implementation, this would run a frame of GBA emulation
          if (this.romInfo.title.toLowerCase().includes("fire") && 
              this.romInfo.title.toLowerCase().includes("red")) {
            // Simple animation for Pokemon title screen
            if (this.frameCount % 60 === 0) {
              // Periodic flash or update
              for (let i = 0; i < 1000; i++) {
                const x = Math.floor(Math.random() * 240);
                const y = Math.floor(Math.random() * 160);
                const idx = (y * 240 + x) * 4;
                
                // Create sparkling effect
                this.frameBuffer[idx] = 255;
                this.frameBuffer[idx + 1] = 255;
                this.frameBuffer[idx + 2] = 220;
              }
            }
          } else {
            // Generic screen updates
            for (let i = 0; i < 1000; i++) {
              const idx = Math.floor(Math.random() * (this.frameBuffer.length / 4)) * 4;
              this.frameBuffer[idx] = Math.floor(Math.random() * 255);
              this.frameBuffer[idx + 1] = Math.floor(Math.random() * 255);
              this.frameBuffer[idx + 2] = Math.floor(Math.random() * 255);
            }
          }
          
          // Update TV screen
          const imgData = new ImageData(
            new Uint8ClampedArray(this.frameBuffer),
            240,
            160
          );
          tvRenderer.context.putImageData(imgData, 0, 0);
          tvRenderer.texture.needsUpdate = true;
        }
        
        saveCurrentState() {
          this.saveState = "Mock save state";
          return true;
        }
        
        loadSavedState() {
          if (!this.saveState) return false;
          return true;
        }
        
        setKeys(keys) {
          this.currentKeys = keys;
        }
        
        getFrame() {
          return this.frameBuffer;
        }
      }
      
      // AI Agent for Pokemon FireRed
      class PokemonAI {
        constructor(emulator) {
          this.emulator = emulator;
          this.isActive = false;
          this.isTrained = false;
          this.frameCounter = 0;
          this.gameState = "title"; // title, overworld, battle, menu
          this.battleCounter = 0;
          this.moveCounter = 0;
          this.pathCount = 0;
          
          // Define action sequences for different game states
          this.actionSequences = {
            title: [
              { keys: new Set(['start']), frames: 30, log: "Pressing START at title screen" }
            ],
            intro: [
              { keys: new Set(['a']), frames: 20, log: "Advancing intro dialog" },
              { keys: new Set([]), frames: 10 },
              { keys: new Set(['a']), frames: 20 },
              { keys: new Set([]), frames: 10 },
              { keys: new Set(['a']), frames: 20, log: "Continuing intro sequence" }
            ],
            overworld: [
              { keys: new Set(['right']), frames: 40 },
              { keys: new Set(['up']), frames: 40, log: "Exploring the map" },
              { keys: new Set(['right']), frames: 30 },
              { keys: new Set(['down']), frames: 25 },
              { keys: new Set(['left']), frames: 20 },
              { keys: new Set(['a']), frames: 15, log: "Checking for items/NPCs" }
            ],
            battle: [
              { keys: new Set(['a']), frames: 15, log: "Selecting FIGHT" },
              { keys: new Set([]), frames: 10 },
              { keys: new Set(['a']), frames: 15, log: "Using most effective move" },
              { keys: new Set([]), frames: 60 },
              { keys: new Set(['a']), frames: 15, log: "Continuing battle dialog" },
              { keys: new Set([]), frames: 30 }
            ],
            pokecenter: [
              { keys: new Set(['a']), frames: 20, log: "Talking to Nurse Joy" },
              { keys: new Set([]), frames: 40 },
              { keys: new Set(['a']), frames: 20, log: "Healing Pokemon" },
              { keys: new Set([]), frames: 60 },
              { keys: new Set(['a']), frames: 20 },
              { keys: new Set(['b']), frames: 20, log: "Exiting Pokecenter" }
            ]
          };
          
          // Current position in sequence
          this.sequenceIndex = 0;
          this.currentMode = "title";
        }
        
        async train() {
          aiStatus.textContent = "Training";
          aiStatus.className = "status-badge status-training";
          
          this.addLog("Initializing Pokemon FireRed AI training...");
          
          // Simulate AI training
          await this.trainStage("Analyzing game patterns", 20);
          await this.trainStage("Learning battle strategies", 30);
          await this.trainStage("Optimizing route navigation", 25);
          await this.trainStage("Building Pokemon type effectiveness matrix", 25);
          
          this.isTrained = true;
          aiStatus.textContent = "Trained";
          aiStatus.className = "status-badge status-inactive";
          
          this.addLog("AI training complete! Ready to play Pokemon FireRed");
          return true;
        }
        
        async trainStage(stageName, percent) {
          this.addLog(`${stageName}...`);
          
          // Simulate processing time
          await new Promise(resolve => setTimeout(resolve, 800));
          
          this.addLog(`${stageName}: Complete`);
          return true;
        }
        
        start() {
          this.isActive = true;
          this.frameCounter = 0;
          this.sequenceIndex = 0;
          this.currentMode = this.detectGameState();
          
          aiStatus.textContent = "Active";
          aiStatus.className = "status-badge status-active";
          
          this.addLog("AI agent activated for Pokemon FireRed");
          this.addLog(`Current game state: ${this.currentMode}`);
        }
        
        stop() {
          this.isActive = false;
          aiStatus.textContent = this.isTrained ? "Trained" : "Inactive";
          aiStatus.className = "status-badge status-inactive";
          this.addLog("AI agent deactivated");
        }
        
        detectGameState() {
          // In a real implementation, this would analyze the screen
          // For the demo, we'll cycle through states
          this.stateCounter = (this.stateCounter || 0) + 1;
          
          if (this.stateCounter < 3) return "title";
          if (this.stateCounter < 6) return "intro";
          
          // After intro, alternate between overworld and battles
          if (this.stateCounter % 8 < 5) return "overworld";
          if (this.stateCounter % 20 === 0) return "pokecenter";
          return "battle";
        }
        
        getNextAction() {
          if (!this.isActive) return new Set();
          
          // Every 180 frames (3 seconds), reassess game state
          if (this.frameCounter % 180 === 0) {
            const newState = this.detectGameState();
            if (newState !== this.currentMode) {
              this.currentMode = newState;
              this.sequenceIndex = 0;
              this.addLog(`Game state changed to: ${this.currentMode}`);
            }
          }
          
          // Get current sequence for the mode
          const sequence = this.actionSequences[this.currentMode];
          if (!sequence) return new Set();
          
          const action = sequence[this.sequenceIndex];
          
          // Increment frame counter
          this.frameCounter++;
          
          // Check if we need to move to next action
          if (this.frameCounter % action.frames === 0) {
            // Log message if there is one
            if (action.log && this.sequenceIndex === 0) {
              this.addLog(action.log);
            }
            
            // Move to next action in sequence
            this.sequenceIndex = (this.sequenceIndex + 1) % sequence.length;
            
            // If we're starting a new loop of the sequence and in overworld,
            // occasionally change states to simulate finding a battle
            if (this.sequenceIndex === 0 && this.currentMode === "overworld") {
              this.pathCount++;
              
              // Every so often, find a battle
              if (this.pathCount % 3 === 0) {
                this.addLog("Wild Pokemon appeared!");
                this.currentMode = "battle";
              }
              
              // Occasionally visit PokeCenter
              if (this.pathCount % 7 === 0) {
                this.addLog("Heading to Pokemon Center to heal");
                this.currentMode = "pokecenter";
              }
            }
          }
          
          return action.keys;
        }
        
        addLog(message) {
          const entry = document.createElement('p');
          entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
          aiLog.appendChild(entry);
          aiLog.scrollTop = aiLog.scrollHeight;
        }
      }
      
      // Helper to add log entry
      function addLog(message) {
        const entry = document.createElement('p');
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        aiLog.appendChild(entry);
        aiLog.scrollTop = aiLog.scrollHeight;
      }
      
      // Set up drag and drop for ROM uploads
      uploadArea.addEventListener('click', () => {
        romInput.click();
      });
      
      romInput.addEventListener('change', handleFileSelect);
      
      uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.style.borderColor = 'var(--accent)';
      });
      
      uploadArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.style.borderColor = '#444';
      });
      
      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.style.borderColor = '#444';
        
        if (e.dataTransfer.files.length > 0) {
          const file = e.dataTransfer.files[0];
          if (file.name.endsWith('.gba')) {
            romInput.files = e.dataTransfer.files;
            handleFileSelect(e);
          } else {
            alert('Please upload a valid GBA ROM file (.gba)');
          }
        }
      });
      
      // Handle file selection
      function handleFileSelect(event) {
        const file = event.target.files[0] || event.dataTransfer.files[0];
        
        if (!file) return;
        if (!file.name.endsWith('.gba')) {
          alert('Please upload a valid GBA ROM file (.gba)');
          return;
        }
        
        const reader = new FileReader();
        reader.onload = function(e) {
          romData = e.target.result;
          romData.name = file.name;
          
          // Update UI
          romName.textContent = file.name;
          romName.style.display = 'block';
          uploadArea.querySelector('p').style.display = 'none';
          
          // Enable buttons
          startBtn.disabled = false;
          resetBtn.disabled = false;
          
          addLog(`ROM loaded: ${file.name}`);
        };
        
        reader.readAsArrayBuffer(file);
      }
      
      // Set up game loop
      function startGameLoop() {
        if (gameLoop) return; // Already running
        
        gameLoop = setInterval(() => {
          // If AI is playing, get its actions
          if (isAIPlaying && aiAgent) {
            currentKeys = aiAgent.getNextAction();
            updateButtonUI(currentKeys);
          }
          
          // Send keys to emulator
          if (emulator) {
            emulator.setKeys(currentKeys);
          }
        }, 16); // ~60fps
      }
      
      function stopGameLoop() {
        if (gameLoop) {
          clearInterval(gameLoop);
          gameLoop = null;
        }
      }
      
      // Update button UI to show pressed state
      function updateButtonUI(keys) {
        // Reset all buttons
        document.querySelectorAll('.btn[data-key]').forEach(btn => {
          btn.style.backgroundColor = '';
        });
        
        // Highlight pressed buttons
        keys.forEach(key => {
          const btn = document.querySelector(`.btn[data-key="${key}"]`);
          if (btn) {
            btn.style.backgroundColor = 'var(--accent)';
          }
        });
      }
      
      // Button event handlers
      startBtn.addEventListener('click', () => {
        if (!romData) {
          alert('Please upload a ROM file first');
          return;
        }
        
        if (!emulator) {
          emulator = new GBAEmulator(romData);
          
          // Initialize AI agent based on the game
          if (romData.name.toLowerCase().includes('pokemon') || 
              romData.name.toLowerCase().includes('fire') ||
              romData.name.toLowerCase().includes('red')) {
            aiAgent = new PokemonAI(emulator);
            addLog("Pokemon game detected! Using specialized Pokemon AI agent");
          } else {
            aiAgent = new PokemonAI(emulator); // Use Pokemon AI for demo
            addLog("Using generic AI agent");
          }
          
          // Enable AI buttons
          aiPlayBtn.disabled = false;
          aiTrainBtn.disabled = false;
        }
        
        // Start game
        emulator.start();
        isGameRunning = true;
        
        // Update buttons
        startBtn.disabled = true;
        pauseBtn.disabled = false;
        saveBtn.disabled = false;
        loadBtn.disabled = false;
        
        // Start game loop
        startGameLoop();
        
        addLog("Game started");
      });
      
      pauseBtn.addEventListener('click', () => {
        if (!emulator || !isGameRunning) return;
        
        emulator.pause();
        isGameRunning = false;
        
        // Update buttons
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        
        // Stop game loop
        stopGameLoop();
        
        addLog("Game paused");
      });
      
      resetBtn.addEventListener('click', () => {
        if (!emulator) return;
        
        // Stop AI if running
        if (isAIPlaying && aiAgent) {
          aiAgent.stop();
          isAIPlaying = false;
          aiPlayBtn.disabled = false;
          aiStopBtn.disabled = true;
        }
        
        emulator.reset();
        isGameRunning = false;
        
        // Update buttons
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        
        // Stop game loop
        stopGameLoop();
        
        // Clear pressed keys
        currentKeys.clear();
        updateButtonUI(currentKeys);
        
        addLog("Game reset");
      });
      
      saveBtn.addEventListener('click', () => {
        if (!emulator) return;
        
        if (emulator.saveCurrentState()) {
          loadBtn.disabled = false;
          addLog("Game state saved");
        }
      });
      
      loadBtn.addEventListener('click', () => {
        if (!emulator) return;
        
        if (emulator.loadSavedState()) {
          addLog("Game state loaded");
          
          if (!isGameRunning) {
            startBtn.disabled = false;
          }
        }
      });
      
      aiPlayBtn.addEventListener('click', () => {
        if (!emulator || !aiAgent) return;
        
        // Start AI
        aiAgent.start();
        isAIPlaying = true;
        
        // Update button states
        aiPlayBtn.disabled = true;
        aiStopBtn.disabled = false;
        
        // If game is not running, start it
        if (!isGameRunning) {
          emulator.start();
          isGameRunning = true;
          startBtn.disabled = true;
          pauseBtn.disabled = false;
          startGameLoop();
        }
      });
      
      aiStopBtn.addEventListener('click', () => {
        if (!aiAgent) return;
        
        // Stop AI
        aiAgent.stop();
        isAIPlaying = false;
        
        // Update button states
        aiPlayBtn.disabled = false;
        aiStopBtn.disabled = true;
        
        // Clear all active buttons
        currentKeys.clear();
        updateButtonUI(currentKeys);
      });
      
      aiTrainBtn.addEventListener('click', async () => {
        if (!aiAgent) return;
        
        // Disable buttons during training
        aiTrainBtn.disabled = true;
        aiPlayBtn.disabled = true;
        
        // Show loading indicator
        const loadingIndicator = document.createElement('span');
        loadingIndicator.className = 'loading';
        aiTrainBtn.appendChild(loadingIndicator);
        
        // Train the AI
        await aiAgent.train();
        
        // Remove loading indicator
        aiTrainBtn.removeChild(loadingIndicator);
        
        // Update buttons
        aiTrainBtn.disabled = false;
        aiPlayBtn.disabled = false;
      });
      
      // Close tutorial modal
      closeTutorial.addEventListener('click', () => {
        tutorialModal.style.opacity = '0';
        setTimeout(() => {
          tutorialModal.style.display = 'none';
        }, 300);
      });
      
      startTutorial.addEventListener('click', () => {
        tutorialModal.style.opacity = '0';
        setTimeout(() => {
          tutorialModal.style.display = 'none';
        }, 300);
      });
      
      // Keyboard controls
      const keyMap = {
        'w': 'up',
        'a': 'left',
        's': 'down',
        'd': 'right',
        'z': 'b',
        'x': 'a',
        'q': 'l',
        'e': 'r',
        ' ': 'select',
        'Enter': 'start'
      };
      
      document.addEventListener('keydown', (e) => {
        if (!isGameRunning || isAIPlaying) return;
        
        const key = keyMap[e.key];
        if (key) {
          currentKeys.add(key);
          updateButtonUI(currentKeys);
          e.preventDefault();
        }
      });
      
      document.addEventListener('keyup', (e) => {
        if (!isGameRunning || isAIPlaying) return;
        
        const key = keyMap[e.key];
        if (key) {
          currentKeys.delete(key);
          updateButtonUI(currentKeys);
          e.preventDefault();
        }
      });
      
      // Controller buttons
      document.querySelectorAll('.btn[data-key]').forEach(btn => {
        const key = btn.dataset.key;
        
        btn.addEventListener('mousedown', () => {
          if (!isGameRunning || isAIPlaying) return;
          currentKeys.add(key);
          updateButtonUI(currentKeys);
        });
        
        btn.addEventListener('mouseup', () => {
          if (!isGameRunning || isAIPlaying) return;
          currentKeys.delete(key);
          updateButtonUI(currentKeys);
        });
        
        btn.addEventListener('touchstart', (e) => {
          if (!isGameRunning || isAIPlaying) return;
          e.preventDefault();
          currentKeys.add(key);
          updateButtonUI(currentKeys);
        });
        
        btn.addEventListener('touchend', (e) => {
          if (!isGameRunning || isAIPlaying) return;
          e.preventDefault();
          currentKeys.delete(key);
          updateButtonUI(currentKeys);
        });
      });
    });
  </script>
</body>
</html>
