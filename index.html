<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Rob & Nano - Memories Aurora</title>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400..900;1,400..900&family=Poppins:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000; /* dark background to show glow / particles */
      font-family: 'Poppins', sans-serif;
    }
    #memories {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
    }
    canvas { display: block; } 
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>
</head>
<body>
  <canvas id="bg"></canvas>
  <div id="memories"></div> <!-- maybe overlay UI etc. -->
  <script>
    const canvas = document.getElementById('bg');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    // Particle background
    const particleCount = 2000;
    const particles = new THREE.BufferGeometry();
    const positions = [];
    for (let i=0; i<particleCount; i++) {
      positions.push(
        (Math.random()-0.5)*200, // x
        (Math.random()-0.5)*200, // y
        (Math.random()-0.5)*200  // z
      );
    }
    particles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    const pMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, opacity: 0.7, transparent: true });
    const particleSystem = new THREE.Points(particles, pMaterial);
    scene.add(particleSystem);

    // Memory images as planes
    const loader = new THREE.TextureLoader();
    const imageMeshes = [];
    for (let i = 1; i <= 20; i++) {
      loader.load(`instagram${i}.png`, (texture) => {
        const ratio = texture.image.height / texture.image.width;
        const geom = new THREE.PlaneGeometry(8, 8 * ratio);
        const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0.9 });
        const mesh = new THREE.Mesh(geom, mat);

        // random initial positions in a sphere or donut
        const phi = Math.acos( 2*Math.random() - 1 );
        const theta = 2 * Math.PI * Math.random();
        const radius = 40 + Math.random()*20;
        mesh.position.set(
          radius * Math.sin(phi) * Math.cos(theta),
          radius * Math.sin(phi) * Math.sin(theta),
          radius * Math.cos(phi)
        );
        mesh.lookAt(0,0,0);

        scene.add(mesh);
        imageMeshes.push(mesh);

        // gentle float animation
        gsap.to(mesh.position, {
          x: mesh.position.x + (Math.random()-0.5)*10,
          y: mesh.position.y + (Math.random()-0.5)*10,
          z: mesh.position.z + (Math.random()-0.5)*10,
          duration: 8 + Math.random()*5,
          yoyo: true,
          repeat: -1,
          ease: "sine.inOut"
        });
      });
    }

    // Raycaster for hover
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let currentHover = null;

    function onMouseMove(e) {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (e.clientY / window.innerHeight) * 2 + 1;
    }
    window.addEventListener('mousemove', onMouseMove);

    function animate() {
      requestAnimationFrame(animate);
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(imageMeshes);

      if (currentHover && (!intersects.length || intersects[0].object !== currentHover)) {
        // reset previous
        gsap.to(currentHover.scale, { x:1, y:1, z:1, duration: 0.5 });
        gsap.to(currentHover.material, { opacity: 0.9, duration: 0.5 });
        currentHover = null;
      }
      if (intersects.length > 0) {
        const picked = intersects[0].object;
        if (picked !== currentHover) {
          if (currentHover) {
            gsap.to(currentHover.scale, { x:1, y:1, z:1, duration:0.5 });
            gsap.to(currentHover.material, { opacity: 0.9, duration:0.5 });
          }
          currentHover = picked;
          gsap.to(picked.scale, { x:2, y:2, z:2, duration:0.5 });
          gsap.to(picked.material, { opacity: 1.0, duration:0.5 });
        }
      }

      // optionally rotate camera or scene slowly
      scene.rotation.y += 0.001;

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
