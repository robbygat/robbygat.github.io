<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zelda-like Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #222;
            overflow: hidden;
        }
        canvas {
            border: 4px solid #333;
        }
    </style>
</head>
<body>
    <script>
        // Game constants
        const TILE_SIZE = 32;
        const MAP_WIDTH = 30;
        const MAP_HEIGHT = 20;
        const GAME_WIDTH = 640;
        const GAME_HEIGHT = 480;
        const SCALE = 2;
        
        // Game state
        let player;
        let enemies = [];
        let gameMap;
        let camera;
        let sword;
        let gameState = "playing";
        
        // Sound effects
        let sounds = {};
        
        // Game setup
        function setup() {
            createCanvas(GAME_WIDTH, GAME_HEIGHT);
            pixelDensity(1);
            noSmooth();
            frameRate(60);
            
            // Initialize game objects
            gameMap = new GameMap();
            player = new Player(9 * TILE_SIZE, 7 * TILE_SIZE);
            camera = new Camera();
            
            // Create enemies
            createEnemies();
            
            // Setup sounds
            setupSounds();
        }
        
        function setupSounds() {
            sounds.sword = new Howl({
                src: ['data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAAFWgD///////////////////////////////////////////8AAAA8TEFNRTMuMTAwAc0AAAAAAAAAABQgJAguQQAANAAAAVrxraWfAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//sQxAADwAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARMQU1FMy4xMDAzVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQxDoDwAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV'],
                volume: 0.5
            });
            
            sounds.hit = new Howl({
                src: ['data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAADAAAHWwDf39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f//////////////////////////////////////////////////////////////////8AAAA8TEFNRTMuMTAwAc0AAAAAAAAAABQgJAh8QQAANAAAAB1t+zVEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//sQxAADwAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARMQU1FMy4xMDAzVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQxBYDwAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV'],
                volume: 0.5
            });
            
            sounds.enemyDeath = new Howl({
                src: ['data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAAEAAAIHwDMzMzMzMzMzMzMzMzMzMzMzMzMzMzM/////////////////////v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+////////////////////////////////////////////////////////////////AAAA8TEFNRTMuMTAwAc0AAAAAAAAAABQgJAiwQQAANAAAACf+XmK2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//sQxAADwAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARMQU1FMy4xMDAzVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQxBYDwAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV'],
                volume: 0.5
            });
        }
        
        function createEnemies() {
            // Add some enemies to the map
            enemies.push(new Enemy(14 * TILE_SIZE, 8 * TILE_SIZE));
            enemies.push(new Enemy(20 * TILE_SIZE, 12 * TILE_SIZE));
            enemies.push(new Enemy(6 * TILE_SIZE, 15 * TILE_SIZE));
            enemies.push(new Enemy(25 * TILE_SIZE, 5 * TILE_SIZE));
            enemies.push(new Enemy(18 * TILE_SIZE, 18 * TILE_SIZE));
        }
        
        // Main draw loop
        function draw() {
            background(0);
            
            if (gameState === "playing") {
                // Update game objects
                camera.update();
                player.update();
                
                // Update enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    enemies[i].update();
                    if (enemies[i].isDead) {
                        enemies.splice(i, 1);
                    }
                }
                
                // Draw game objects
                push();
                translate(-camera.x, -camera.y);
                
                // Draw map first (background)
                gameMap.display();
                
                // Draw enemies
                enemies.forEach(enemy => enemy.display());
                
                // Draw player
                player.display();
                
                // Draw sword if active
                if (sword && sword.active) {
                    sword.update();
                    sword.display();
                }
                
                pop();
                
                // Draw UI
                drawUI();
            } else if (gameState === "gameOver") {
                displayGameOver();
            }
        }
        
        function drawUI() {
            // Draw health
            fill(255);
            textSize(16);
            textAlign(LEFT, TOP);
            text(`Health: ${player.health}`, 10, 10);
            
            // Draw hearts
            for (let i = 0; i < player.health; i++) {
                fill(255, 0, 0);
                noStroke();
                heart(40 + i * 25, 35, 10);
            }
        }
        
        function heart(x, y, size) {
            beginShape();
            vertex(x, y);
            bezierVertex(x - size / 2, y - size / 2, x - size, y + size / 3, x, y + size);
            bezierVertex(x + size, y + size / 3, x + size / 2, y - size / 2, x, y);
            endShape(CLOSE);
        }
        
        function displayGameOver() {
            background(0);
            fill(255);
            textSize(32);
            textAlign(CENTER, CENTER);
            text("GAME OVER", width / 2, height / 2 - 20);
            textSize(16);
            text("Press R to restart", width / 2, height / 2 + 20);
        }
        
        // Input handling
        function keyPressed() {
            if (gameState === "gameOver" && key === 'r') {
                resetGame();
            }
            
            if (gameState === "playing" && key === ' ') {
                player.attack();
            }
        }
        
        function resetGame() {
            player = new Player(9 * TILE_SIZE, 7 * TILE_SIZE);
            enemies = [];
            createEnemies();
            gameState = "playing";
        }
        
        // Camera class
        class Camera {
            constructor() {
                this.x = 0;
                this.y = 0;
                this.width = GAME_WIDTH;
                this.height = GAME_HEIGHT;
            }
            
            update() {
                // Follow player with camera
                this.x = player.x - this.width / 2;
                this.y = player.y - this.height / 2;
                
                // Clamp camera to map
                this.x = constrain(this.x, 0, gameMap.width - this.width);
                this.y = constrain(this.y, 0, gameMap.height - this.height);
            }
        }
        
        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 16;
                this.height = 24;
                this.speed = 3;
                this.health = 5;
                this.maxHealth = 5;
                this.direction = "down";
                this.isMoving = false;
                this.attackCooldown = 0;
                this.invulnerable = 0;
                this.animation = 0;
                this.animationSpeed = 0.15;
                this.frameCount = 0;
            }
            
            update() {
                // Handle movement
                this.isMoving = false;
                let newX = this.x;
                let newY = this.y;
                
                if (keyIsDown(87) || keyIsDown(UP_ARROW)) { // W or UP
                    newY -= this.speed;
                    this.direction = "up";
                    this.isMoving = true;
                }
                if (keyIsDown(83) || keyIsDown(DOWN_ARROW)) { // S or DOWN
                    newY += this.speed;
                    this.direction = "down";
                    this.isMoving = true;
                }
                if (keyIsDown(65) || keyIsDown(LEFT_ARROW)) { // A or LEFT
                    newX -= this.speed;
                    this.direction = "left";
                    this.isMoving = true;
                }
                if (keyIsDown(68) || keyIsDown(RIGHT_ARROW)) { // D or RIGHT
                    newX += this.speed;
                    this.direction = "right";
                    this.isMoving = true;
                }
                
                // Only update animation when moving
                if (this.isMoving) {
                    this.animation += this.animationSpeed;
                    if (this.animation >= 4) {
                        this.animation = 0;
                    }
                } else {
                    this.animation = 0;
                }
                
                // Check for collisions with the map
                if (!this.collidesWithMap(newX, this.y)) {
                    this.x = newX;
                }
                
                if (!this.collidesWithMap(this.x, newY)) {
                    this.y = newY;
                }
                
                // Update attack cooldown
                if (this.attackCooldown > 0) {
                    this.attackCooldown--;
                }
                
                // Update invulnerability timer
                if (this.invulnerable > 0) {
                    this.invulnerable--;
                }
                
                // Check for collisions with enemies
                if (this.invulnerable <= 0) {
                    for (let enemy of enemies) {
                        if (this.collidesWith(enemy)) {
                            this.takeDamage(1);
                            break;
                        }
                    }
                }
                
                this.frameCount++;
            }
            
            collidesWithMap(x, y) {
                // Check for collision with map boundaries
                if (x < 0 || y < 0 || x + this.width > gameMap.width || y + this.height > gameMap.height) {
                    return true;
                }
                
                // Get the tiles that the player's hitbox overlaps with
                const tileSize = TILE_SIZE;
                const leftTile = floor(x / tileSize);
                const rightTile = floor((x + this.width) / tileSize);
                const topTile = floor(y / tileSize);
                const bottomTile = floor((y + this.height) / tileSize);
                
                // Check each tile for collision
                for (let i = leftTile; i <= rightTile; i++) {
                    for (let j = topTile; j <= bottomTile; j++) {
                        if (gameMap.isSolidTile(i, j)) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            collidesWith(other) {
                return this.x < other.x + other.width &&
                    this.x + this.width > other.x &&
                    this.y < other.y + other.height &&
                    this.y + this.height > other.y;
            }
            
            attack() {
                if (this.attackCooldown <= 0) {
                    sounds.sword.play();
                    this.attackCooldown = 30; // Half a second cooldown
                    
                    // Create sword hitbox based on direction
                    let swordX = this.x;
                    let swordY = this.y;
                    const swordWidth = 20;
                    const swordHeight = 20;
                    
                    switch (this.direction) {
                        case "up":
                            swordX = this.x - 2;
                            swordY = this.y - swordHeight;
                            break;
                        case "down":
                            swordX = this.x - 2;
                            swordY = this.y + this.height;
                            break;
                        case "left":
                            swordX = this.x - swordWidth;
                            swordY = this.y + 2;
                            break;
                        case "right":
                            swordX = this.x + this.width;
                            swordY = this.y + 2;
                            break;
                    }
                    
                    sword = new Sword(swordX, swordY, this.direction, 10);
                    
                    // Check for hits on enemies
                    for (let enemy of enemies) {
                        if (sword.collidesWith(enemy)) {
                            enemy.takeDamage(1);
                        }
                    }
                }
            }
            
            takeDamage(amount) {
                if (this.invulnerable <= 0) {
                    sounds.hit.play();
                    this.health -= amount;
                    this.invulnerable = 60; // 1 second of invulnerability
                    
                    if (this.health <= 0) {
                        gameState = "gameOver";
                    }
                }
            }
            
            display() {
                push();
                if (this.invulnerable > 0 && this.frameCount % 10 < 5) {
                    // Flashing when hit
                    tint(255, 128, 128);
                }
                
                // Draw player sprite based on direction and animation frame
                const frame = floor(this.animation);
                this.drawCharacter(this.x, this.y, this.direction, frame);
                
                pop();
            }
            
            drawCharacter(x, y, direction, frame) {
                // Draw character using p5.js shapes
                push();
                
                // Body
                fill(34, 177, 76); // Green tunic
                noStroke();
                rect(x, y, this.width, this.height);
                
                // Face
                fill(255, 204, 153); // Skin tone
                rect(x + 3, y + 3, this.width - 6, 8);
                
                // Eyes
                fill(0);
                let eyeOffsetX = 0;
                
                if (direction === "left") {
                    eyeOffsetX = -1;
                } else if (direction === "right") {
                    eyeOffsetX = 1;
                }
                
                ellipse(x + 6 + eyeOffsetX, y + 7, 2, 2);
                ellipse(x + 10 + eyeOffsetX, y + 7, 2, 2);
                
                // Hair
                fill(255, 204, 0); // Blonde
                rect(x + 2, y + 1, this.width - 4, 3);
                
                // Hat
                fill(34, 177, 76); // Green
                triangle(x + 2, y + 4, x + this.width - 2, y + 4, x + this.width / 2, y - 6);
                
                // Arms and legs animation
                stroke(34, 177, 76);
                strokeWeight(4);
                
                // Add animation to arms and legs based on direction and movement
                if (direction === "down" || direction === "up") {
                    // Left arm
                    let leftArmY = y + 10;
                    if (this.isMoving) {
                        leftArmY += sin(frame * PI) * 2;
                    }
                    line(x, y + 10, x - 3, leftArmY);
                    
                    // Right arm
                    let rightArmY = y + 10;
                    if (this.isMoving) {
                        rightArmY += sin((frame + 2) * PI) * 2;
                    }
                    line(x + this.width, y + 10, x + this.width + 3, rightArmY);
                    
                    // Legs
                    let leftLegX = x + 5;
                    let rightLegX = x + this.width - 5;
                    let leftLegY = y + this.height;
                    let rightLegY = y + this.height;
                    
                    if (this.isMoving) {
                        leftLegY += sin(frame * PI) * 2;
                        rightLegY += sin((frame + 2) * PI) * 2;
                    }
                    
                    line(x + 5, y + this.height - 4, leftLegX, leftLegY);
                    line(x + this.width - 5, y + this.height - 4, rightLegX, rightLegY);
                } else if (direction === "left" || direction === "right") {
                    // Arms for side view
                    let armX = direction === "left" ? x - 3 : x + this.width + 3;
                    let armY = y + 10;
                    
                    if (this.isMoving) {
                        armY += sin(frame * PI) * 2;
                    }
                    
                    line(direction === "left" ? x : x + this.width, y + 10, armX, armY);
                    
                    // Legs for side view
                    let frontLegX = direction === "left" ? x + 2 : x + this.width - 2;
                    let backLegX = direction === "left" ? x + 7 : x + this.width - 7;
                    let frontLegY = y + this.height;
                    let backLegY = y + this.height;
                    
                    if (this.isMoving) {
                        frontLegY += sin(frame * PI) * 2;
                        backLegY += sin((frame + 2) * PI) * 2;
                    }
                    
                    line(frontLegX, y + this.height - 4, frontLegX, frontLegY);
                    line(backLegX, y + this.height - 4, backLegX, backLegY);
                }
                
                pop();
            }
        }
        
        // Sword class
        class Sword {
            constructor(x, y, direction, duration) {
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.active = true;
                this.duration = duration;
                this.timer = 0;
                
                // Size depends on direction
                if (direction === "left" || direction === "right") {
                    this.width = 20;
                    this.height = 10;
                } else {
                    this.width = 10;
                    this.height = 20;
                }
            }
            
            update() {
                this.timer++;
                if (this.timer >= this.duration) {
                    this.active = false;
                }
            }
            
            collidesWith(other) {
                return this.x < other.x + other.width &&
                    this.x + this.width > other.x &&
                    this.y < other.y + other.height &&
                    this.y + this.height > other.y;
            }
            
            display() {
                push();
                fill(200);
                stroke(100);
                strokeWeight(1);
                
                // Draw sword based on direction
                switch (this.direction) {
                    case "up":
                        rect(this.x, this.y, this.width, this.height);
                        // Draw hilt
                        fill(139, 69, 19); // Brown
                        rect(this.x + 2, this.y + this.height - 5, 6, 10);
                        break;
                    case "down":
                        rect(this.x, this.y, this.width, this.height);
                        // Draw hilt
                        fill(139, 69, 19); // Brown
                        rect(this.x + 2, this.y - 5, 6, 10);
                        break;
                    case "left":
                        rect(this.x, this.y, this.width, this.height);
                        // Draw hilt
                        fill(139, 69, 19); // Brown
                        rect(this.x + this.width - 5, this.y + 2, 10, 6);
                        break;
                    case "right":
                        rect(this.x, this.y, this.width, this.height);
                        // Draw hilt
                        fill(139, 69, 19); // Brown
                        rect(this.x - 5, this.y + 2, 10, 6);
                        break;
                }
                
                pop();
            }
        }
        
        // Enemy class
        class Enemy {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 18;
                this.height = 22;
                this.speed = 1;
                this.health = 3;
                this.maxHealth = 3;
                this.direction = "down";
                this.animation = 0;
                this.animationSpeed = 0.1;
                this.isDead = false;
                this.moveTimer = 0;
                this.moveDirection = floor(random(4));
                this.moveDuration = floor(random(30, 90));
                this.idleDuration = floor(random(30, 60));
                this.state = "moving"; // "moving" or "idle"
                this.invulnerable = 0;
                this.frameCount = 0;
            }
            
            update() {
                if (this.health <= 0 && !this.isDead) {
                    sounds.enemyDeath.play();
                    this.isDead = true;
                    return;
                }
                
                // Update invulnerability
                if (this.invulnerable > 0) {
                    this.invulnerable--;
                }
                
                // Update animation
                if (this.state === "moving") {
                    this.animation += this.animationSpeed;
                    if (this.animation >= 4) {
                        this.animation = 0;
                    }
                    
                    // Move according to current direction
                    let newX = this.x;
                    let newY = this.y;
                    
                    switch (this.moveDirection) {
                        case 0: // Up
                            newY -= this.speed;
                            this.direction = "up";
                            break;
                        case 1: // Right
                            newX += this.speed;
                            this.direction = "right";
                            break;
                        case 2: // Down
                            newY += this.speed;
                            this.direction = "down";
                            break;
                        case 3: // Left
                            newX -= this.speed;
                            this.direction = "left";
                            break;
                    }
                    
                    // Check for collisions with the map
                    if (!this.collidesWithMap(newX, this.y)) {
                        this.x = newX;
                    } else {
                        // Change direction if we hit a wall
                        this.moveDirection = (this.moveDirection + 2) % 4;
                    }
                    
                    if (!this.collidesWithMap(this.x, newY)) {
                        this.y = newY;
                    } else {
                        // Change direction if we hit a wall
                        this.moveDirection = (this.moveDirection + 2) % 4;
                    }
                    
                    // Update move timer
                    this.moveTimer++;
                    if (this.moveTimer >= this.moveDuration) {
                        this.moveTimer = 0;
                        this.state = "idle";
                        this.animation = 0;
                    }
                } else if (this.state === "idle") {
                    // Update idle timer
                    this.moveTimer++;
                    if (this.moveTimer >= this.idleDuration) {
                        this.moveTimer = 0;
                        this.state = "moving";
                        this.moveDirection = floor(random(4));
                        this.moveDuration = floor(random(30, 90));
                    }
                }
                
                this.frameCount++;
            }
            
            collidesWithMap(x, y) {
                // Check for collision with map boundaries
                if (x < 0 || y < 0 || x + this.width > gameMap.width || y + this.height > gameMap.height) {
                    return true;
                }
                
                // Get the tiles that the enemy's hitbox overlaps with
                const tileSize = TILE_SIZE;
                const leftTile = floor(x / tileSize);
                const rightTile = floor((x + this.width) / tileSize);
                const topTile = floor(y / tileSize);
                const bottomTile = floor((y + this.height) / tileSize);
                
                // Check each tile for collision
                for (let i = leftTile; i <= rightTile; i++) {
                    for (let j = topTile; j <= bottomTile; j++) {
                        if (gameMap.isSolidTile(i, j)) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            takeDamage(amount) {
                if (this.invulnerable <= 0) {
                    sounds.hit.play();
                    this.health -= amount;
                    this.invulnerable = 30; // Half a second of invulnerability
                }
            }
            
            display() {
                if (this.isDead) return;
                
                push();
                if (this.invulnerable > 0 && this.frameCount % 8 < 4) {
                    // Flashing when hit
                    tint(255, 128, 128);
                }
                
                // Draw enemy
                const frame = floor(this.animation);
                this.drawEnemy(this.x, this.y, frame);
                
                // Draw health bar
                this.drawHealthBar();
                
                pop();
            }
            
            drawEnemy(x, y, frame) {
                push();
                
                // Body
                fill(204, 0, 0); // Red body
                noStroke();
                rect(x, y, this.width, this.height);
                
                // Face/Eyes
                fill(0);
                ellipse(x + 5, y + 8, 3, 3);
                ellipse(x + this.width - 5, y + 8, 3, 3);
                
                // Mouth
                stroke(0);
                strokeWeight(1);
                line(x + 6, y + 14, x + this.width - 6, y + 14);
                
                // Horns
                fill(100);
                triangle(x + 2, y + 2, x + 2, y - 5, x + 6, y + 2);
                triangle(x + this.width - 2, y + 2, x + this.width - 2, y - 5, x + this.width - 6, y + 2);
                
                // Add animation to legs based on movement
                if (this.state === "moving") {
                    let leftLegX = x + 5;
                    let rightLegX = x + this.width - 5;
                    let legY = y + this.height;
                    
                    if (this.direction === "left" || this.direction === "right") {
                        leftLegX += sin(frame * PI) * 2;
                        rightLegX += sin((frame + 2) * PI) * 2;
                    } else {
                        legY += sin(frame * PI) * 2;
                    }
                    
                    stroke(150, 0, 0);
                    strokeWeight(3);
                    line(x + 5, y + this.height - 3, leftLegX, legY);
                    line(x + this.width - 5, y + this.height - 3, rightLegX, legY);
                }
                
                pop();
            }
            
            drawHealthBar() {
                // Draw health bar above enemy
                const barWidth = this.width;
                const barHeight = 4;
                const x = this.x;
                const y = this.y - 10;
                
                // Background of health bar
                fill(100);
                noStroke();
                rect(x, y, barWidth, barHeight);
                
                // Actual health
                const healthWidth = map(this.health, 0, this.maxHealth, 0, barWidth);
                fill(255, 0, 0);
                rect(x, y, healthWidth, barHeight);
            }
        }
        
        // Game Map class
        class GameMap {
            constructor() {
                this.tileSize = TILE_SIZE;
                this.width = MAP_WIDTH * this.tileSize;
                this.height = MAP_HEIGHT * this.tileSize;
                this.tiles = [];
                
                // Generate a simple map
                this.generateMap();
            }
            
            generateMap() {
                // Initialize empty map
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    this.tiles[y] = [];
                    for (let x = 0; x < MAP_WIDTH; x++) {
                        // 0 = grass, 1 = water, 2 = tree, 3 = rock
                        this.tiles[y][x] = 0;
                    }
                }
                
                // Add border
                for (let x = 0; x < MAP_WIDTH; x++) {
                    this.tiles[0][x] = 3; // Top border
                    this.tiles[MAP_HEIGHT - 1][x] = 3; // Bottom border
                }
                
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    this.tiles[y][0] = 3; // Left border
                    this.tiles[y][MAP_WIDTH - 1] = 3; // Right border
                }
                
                // Add some water
                for (let i = 0; i < 10; i++) {
                    const x = floor(random(2, MAP_WIDTH - 2));
                    const y = floor(random(2, MAP_HEIGHT - 2));
                    this.tiles[y][x] = 1;
                    
                    // Add some surrounding water
                    for (let j = 0; j < 5; j++) {
                        const nx = x + floor(random(-2, 3));
                        const ny = y + floor(random(-2, 3));
                        if (nx > 1 && nx < MAP_WIDTH - 2 && ny > 1 && ny < MAP_HEIGHT - 2) {
                            this.tiles[ny][nx] = 1;
                        }
                    }
                }
                
                // Add some trees
                for (let i = 0; i < 20; i++) {
                    const x = floor(random(2, MAP_WIDTH - 2));
                    const y = floor(random(2, MAP_HEIGHT - 2));
                    if (this.tiles[y][x] === 0) {
                        this.tiles[y][x] = 2;
                    }
                }
                
                // Add some rocks
                for (let i = 0; i < 15; i++) {
                    const x = floor(random(2, MAP_WIDTH - 2));
                    const y = floor(random(2, MAP_HEIGHT - 2));
                    if (this.tiles[y][x] === 0) {
                        this.tiles[y][x] = 3;
                    }
                }
                
                // Make sure player starting area is clear
                this.tiles[7][9] = 0;
                this.tiles[7][8] = 0;
                this.tiles[7][10] = 0;
                this.tiles[6][9] = 0;
                this.tiles[8][9] = 0;
            }
            
            isSolidTile(x, y) {
                // Check if coordinates are valid
                if (x < 0 || y < 0 || x >= MAP_WIDTH || y >= MAP_HEIGHT) {
                    return true;
                }
                
                // Water, trees, and rocks are solid
                const tile = this.tiles[y][x];
                return tile === 1 || tile === 2 || tile === 3;
            }
            
            display() {
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    for (let x = 0; x < MAP_WIDTH; x++) {
                        const tileType = this.tiles[y][x];
                        this.drawTile(x * this.tileSize, y * this.tileSize, tileType);
                    }
                }
            }
            
            drawTile(x, y, type) {
                switch (type) {
                    case 0: // Grass
                        fill(76, 153, 0);
                        noStroke();
                        rect(x, y, this.tileSize, this.tileSize);
                        
                        // Add some grass detail
                        stroke(50, 120, 0);
                        for (let i = 0; i < 3; i++) {
                            const gx = x + random(2, this.tileSize - 2);
                            const gy = y + random(2, this.tileSize - 2);
                            line(gx, gy, gx, gy - 3);
                        }
                        break;
                        
                    case 1: // Water
                        fill(0, 102, 204);
                        noStroke();
                        rect(x, y, this.tileSize, this.tileSize);
                        
                        // Add water ripple effect
                        stroke(0, 153, 255, 100);
                        noFill();
                        const time = frameCount * 0.05;
                        const waveSize = 3 + sin(time) * 2;
                        ellipse(x + this.tileSize / 2, y + this.tileSize / 2, waveSize, waveSize);
                        break;
                        
                    case 2: // Tree
                        // Draw grass background
                        fill(76, 153, 0);
                        noStroke();
                        rect(x, y, this.tileSize, this.tileSize);
                        
                        // Tree trunk
                        fill(102, 51, 0);
                        rect(x + this.tileSize / 2 - 3, y + this.tileSize / 2, 6, this.tileSize / 2);
                        
                        // Tree top
                        fill(0, 102, 0);
                        ellipse(x + this.tileSize / 2, y + this.tileSize / 3, this.tileSize - 6, this.tileSize - 6);
                        break;
                        
                    case 3: // Rock
                        fill(120);
                        noStroke();
                        rect(x, y, this.tileSize, this.tileSize);
                        
                        // Add rock texture
                        stroke(90);
                        strokeWeight(1);
                        line(x + 5, y + 5, x + 10, y + 8);
                        line(x + 20, y + 15, x + 25, y + 10);
                        line(x + 8, y + 25, x + 15, y + 20);
                        break;
                }
            }
        }
    </script>
</body>
</html>
