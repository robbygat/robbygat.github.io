<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Ensure proper scaling and prevent user scaling which can interfere -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>robbygat.com by Robert Gatzke</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <!-- Removed Three.js as it wasn't used -->
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: white;
            font-family: Arial, sans-serif;
            position: relative;
            /* Prevent text selection during taps */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        canvas {
            display: block;
            /* Prevent the tap highlight effect on mobile */
            -webkit-tap-highlight-color: transparent;
        }

        /* --- CRT Effect Overlays --- */
        body::before {
            content: "";
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none; /* Allow interactions to pass through */
            z-index: 2;
             /* --- UNCOMMENT BELOW TO TEST WITHOUT THIS OVERLAY --- */
             /* display: none; */
        }

        body::after {
            content: "";
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0.15;
            z-index: 2;
            pointer-events: none; /* Allow interactions to pass through */
            animation: flicker 0.15s infinite alternate;
             /* --- UNCOMMENT BELOW TO TEST WITHOUT THIS OVERLAY --- */
             /* display: none; */
        }

        @keyframes flicker {
            0% { opacity: 0.15; }
            100% { opacity: 0.12; }
        }
        /* --- End CRT Effect Overlays --- */

    </style>
</head>
<body>
    <script>
        // Cell class definition (mostly unchanged, ensure 'contains' uses current radius)
        class Cell {
             constructor(x, y, r, color, text, link) {
                this.position = createVector(x, y);
                this.velocity = p5.Vector.random2D().mult(random(0.5, 1.5));
                this.radius = r;
                this.baseRadius = r;
                this.pulseAmount = random(0.05, 0.15);
                this.pulseSpeed = random(0.01, 0.03);
                this.pulseOffset = random(0, TWO_PI);
                this.color = color;
                this.text = text;
                this.link = link;
                this.target = createVector(random(width), random(height));
                this.maxSpeed = random(1, 2);
                this.changeTargetCounter = 0;
                this.changeTargetInterval = random(100, 200);
                this.fontSize = null;
            }

            update() {
                this.changeTargetCounter++;
                if (this.changeTargetCounter > this.changeTargetInterval) {
                    this.target = createVector(random(width), random(height));
                    this.changeTargetCounter = 0;
                    this.changeTargetInterval = random(100, 200);
                }

                this.radius = this.baseRadius * (1 + this.pulseAmount * sin(frameCount * this.pulseSpeed + this.pulseOffset));

                if (!this.fontSize) {
                    this.calculateFontSize();
                }

                let desired = p5.Vector.sub(this.target, this.position);
                let distance = desired.mag();

                if (distance < 100) {
                    let m = map(distance, 0, 100, 0, this.maxSpeed);
                    desired.setMag(m);
                } else {
                    desired.setMag(this.maxSpeed);
                }

                let steer = p5.Vector.sub(desired, this.velocity);
                steer.limit(0.1);
                this.velocity.add(steer);

                for (let other of cells) {
                    if (other !== this) {
                        let d = p5.Vector.dist(this.position, other.position);
                        if (d < this.radius + other.radius + 15) { // Use current radius for avoidance
                            let avoid = p5.Vector.sub(this.position, other.position);
                            avoid.setMag(0.5);
                            this.velocity.add(avoid);
                        }
                    }
                }

                let buffer = this.radius + 10;
                if (this.position.x < buffer) this.velocity.x += 0.2;
                else if (this.position.x > width - buffer) this.velocity.x -= 0.2;
                if (this.position.y < buffer) this.velocity.y += 0.2;
                else if (this.position.y > height - buffer) this.velocity.y -= 0.2;

                if (this.velocity.magSq() < 0.01) {
                   this.velocity = p5.Vector.random2D().mult(0.1);
                }

                this.velocity.limit(this.maxSpeed);
                this.position.add(this.velocity);

                this.position.x = constrain(this.position.x, this.radius, width - this.radius);
                this.position.y = constrain(this.position.y, this.radius, height - this.radius);
            }

            calculateFontSize() {
                let testSize = this.baseRadius * 0.8;
                textSize(testSize);
                while (textWidth(this.text) > this.baseRadius * 1.6 && testSize > 8) {
                    testSize -= 1;
                    textSize(testSize);
                }
                this.fontSize = testSize;
            }

            draw() {
                noStroke();
                fill(this.color);
                ellipse(this.position.x, this.position.y, this.radius * 2); // Use current radius

                if (this.fontSize) {
                    fill(255);
                    textAlign(CENTER, CENTER);
                    textSize(this.fontSize);
                    text(this.text, this.position.x, this.position.y);
                }
            }

            contains(px, py) {
                if (typeof px !== 'number' || typeof py !== 'number') {
                    return false;
                }
                // Check against the *current* radius, as it pulses
                let d = dist(px, py, this.position.x, this.position.y);
                return d < this.radius;
            }
        }

        // --- Global Variables ---
        let cells = [];
        let cellData = [
            { text: "X", link: "https://x.com/robbygat", color: "#1DA1F2" },
            { text: "Instagram", link: "https://www.instagram.com/robbygat/", color: "#C13584" },
            { text: "Art", link: "https://rarevance.com", color: "#FF6B6B" },
            { text: "Soon", link: "#", color: "#43AA8B" },
            { text: "Music", link: "https://linktr.ee/internetcowboy", color: "#F9C74F" },
            { text: "Photography", link: "https://www.instagram.com/robbygatzke/", color: "#8A2BE2" },
            { text: "Contact", link: "mailto:robby@robbygat.com", color: "#FF4500" }
        ];
        let cnv; // To hold the canvas element reference

        // --- p5.js Setup ---
        function setup() {
            cnv = createCanvas(windowWidth, windowHeight);

            // --- Attach direct touch listener to the canvas ---
            // Using { passive: false } because we might call preventDefault
            cnv.elt.addEventListener('touchend', handleTouchEnd, { passive: false });

            // Prevent scrolling/zooming initiated *on the canvas*
            // Needed esp. on iOS to allow immediate response to touchend
            cnv.elt.addEventListener('touchstart', (e) => {
                 // Check if the touch is over a cell, only preventDefault then? Might be too complex.
                 // Let's start by always preventing default on touchstart ON the canvas.
                 e.preventDefault();
            }, { passive: false });

             // It might also be necessary to prevent touchmove
            cnv.elt.addEventListener('touchmove', (e) => {
                 e.preventDefault();
            }, { passive: false });


            // Create cells
            for (let i = 0; i < cellData.length; i++) {
                let r = random(60, 85); // Even slightly larger for easier tapping
                let x = random(r, width - r);
                let y = random(r, height - r);
                cells.push(new Cell(x, y, r, cellData[i].color, cellData[i].text, cellData[i].link));
            }
            console.log("Setup complete. Touch listener attached."); // Debug log
        }

        // --- p5.js Draw ---
        function draw() {
            background(255);
            for (let cell of cells) {
                cell.update();
                cell.draw();
            }
        }

        // --- Interaction Check Function ---
        function checkInteraction(px, py) {
            console.log(`Checking interaction at screen coords: ${px.toFixed(1)}, ${py.toFixed(1)}`);
            let interactedCell = null;
            // Iterate from top (last drawn) to bottom
            for (let i = cells.length - 1; i >= 0; i--) {
                if (cells[i].contains(px, py)) {
                    console.log(`HIT: Cell "${cells[i].text}" contains point.`);
                    interactedCell = cells[i];
                    break; // Found the topmost cell hit
                }
            }

            if (interactedCell) {
                console.log(`Action: Opening link for "${interactedCell.text}": ${interactedCell.link}`);
                if (interactedCell.link && interactedCell.link !== "#") {
                    // Try opening the link - this is the critical part for mobile
                    const newWindow = window.open(interactedCell.link, '_blank');
                    if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
                         console.warn('window.open() was blocked or failed for:', interactedCell.link);
                         // Alert might work on some mobile browsers if popup fails
                         // alert(`Could not open link automatically. Please ensure popups are allowed for this site.`);
                     }
                } else {
                    console.log(`Info: Cell "${interactedCell.text}" has no valid link.`);
                }
                return true; // Indicate that an interaction occurred
            } else {
                 console.log("Miss: No cell contains the interaction point.");
                 return false; // No interaction occurred
            }
        }

        // --- Touch Event Handler (attached directly to canvas) ---
        function handleTouchEnd(event) {
            console.log("Canvas 'touchend' event fired.");

            // We only proceed if a cell was hit, otherwise allow default behaviors
            let interactionDetected = false;

            // Use the first touch point that was released
            if (event.changedTouches.length > 0) {
                // Get coordinates relative to the viewport
                let touchX = event.changedTouches[0].clientX;
                let touchY = event.changedTouches[0].clientY;

                // Since canvas fills the window, clientX/Y should map directly
                // If canvas had offsets, you'd need:
                // let rect = cnv.elt.getBoundingClientRect();
                // touchX = event.changedTouches[0].clientX - rect.left;
                // touchY = event.changedTouches[0].clientY - rect.top;

                interactionDetected = checkInteraction(touchX, touchY);
            }

            // *** Crucial: Only prevent default if we successfully interacted with a cell ***
            // This stops the browser from doing things like zooming on double-tap AFTER our action.
            if (interactionDetected) {
                console.log("Interaction handled, calling event.preventDefault()");
                event.preventDefault();
            } else {
                 console.log("No cell interaction, allowing default browser behavior.");
            }
        }

        // --- Keep mousePressed for Desktop Clicks ---
        function mousePressed() {
            // mouseX, mouseY are reliable in p5's mousePressed for desktop
            console.log("p5 'mousePressed' event fired.");
            const interacted = checkInteraction(mouseX, mouseY);
            // Prevent default p5 behavior if interaction occurred (may not be necessary but good practice)
            if (interacted) {
                 return false;
            }
        }

        // --- Window Resize ---
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            for (let cell of cells) {
                 cell.calculateFontSize(); // Recalculate text size
                 // Optional: Re-constrain/reset positions if needed
                 cell.target = createVector(random(width), random(height));
                 cell.position.x = constrain(cell.position.x, cell.radius, width - cell.radius);
                 cell.position.y = constrain(cell.position.y, cell.radius, height - cell.radius);
             }
             console.log("Window resized."); // Debug log
        }

        // We are using a direct listener, so the p5 global touchEnded is not needed
        // function touchEnded() { /* ... */ }

    </script>
</body>
</html>
